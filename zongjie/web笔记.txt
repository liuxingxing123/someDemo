写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？
key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。
1. 更准确
因为带key就不是就地复用了，在sameNode函数 a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。
2. 更快
利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map会比遍历更快。)

Set 和 Map 主要的应用场景在于 数据重组 和 数据储存

Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构

1. 集合（Set）
ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。

Set 本身是一种构造函数，用来生成 Set 数据结构。

new Set([iterable])
举个例子：

const s = new Set()
[1, 2, 3, 4, 3, 2, 1].forEach(x => s.add(x))

for (let i of s) {
    console.log(i)	// 1 2 3 4
}

// 去重数组的重复对象
let arr = [1, 2, 3, 2, 1, 1]
[... new Set(arr)]	// [1, 2, 3]
Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。

向 Set 加入值的时候，不会发生类型转换，所以5和"5"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是**NaN等于自身，而精确相等运算符认为NaN不等于自身。**

let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}

let set1 = new Set()
set1.add(5)
set1.add('5')
console.log([...set1])	// [5, "5"]
Set 实例属性

constructor： 构造函数

size：元素数量

let set = new Set([1, 2, 3, 2, 1])

console.log(set.length)	// undefined
console.log(set.size)	// 3
Set 实例方法

操作方法
add(value)：新增，相当于 array里的push

delete(value)：存在即删除集合中value

has(value)：判断集合中是否存在 value

clear()：清空集合

let set = new Set()
set.add(1).add(2).add(1)

set.has(1)	// true
set.has(3)	// false
set.delete(1)	
set.has(1)	// false
Array.from 方法可以将 Set 结构转为数组

const items = new Set([1, 2, 3, 2])
const array = Array.from(items)
console.log(array)	// [1, 2, 3]
// 或
const arr = [...items]
console.log(arr)	// [1, 2, 3]
遍历方法（遍历顺序为插入顺序）
keys()：返回一个包含集合中所有键的迭代器

values()：返回一个包含集合中所有值得迭代器

entries()：返回一个包含Set对象中所有元素得键值对迭代器

forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，没有返回值

let set = new Set([1, 2, 3])
console.log(set.keys())	// SetIterator {1, 2, 3}
console.log(set.values())	// SetIterator {1, 2, 3}
console.log(set.entries())	// SetIterator {1, 2, 3}

for (let item of set.keys()) {
  console.log(item);
}	// 1	2	 3
for (let item of set.entries()) {
  console.log(item);
}	// [1, 1]	[2, 2]	[3, 3]

set.forEach((value, key) => {
    console.log(key + ' : ' + value)
})	// 1 : 1	2 : 2	3 : 3
console.log([...set])	// [1, 2, 3]
Set 可默认遍历，默认迭代器生成函数是 values() 方法

Set.prototype[Symbol.iterator] === Set.prototype.values	// true
所以， Set可以使用 map、filter 方法

let set = new Set([1, 2, 3])
set = new Set([...set].map(item => item * 2))
console.log([...set])	// [2, 4, 6]

set = new Set([...set].filter(item => (item >= 4)))
console.log([...set])	//[4, 6]
因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）

let set1 = new Set([1, 2, 3])
let set2 = new Set([4, 3, 2])

let intersect = new Set([...set1].filter(value => set2.has(value)))
let union = new Set([...set1, ...set2])
let difference = new Set([...set1].filter(value => !set2.has(value)))

console.log(intersect)	// Set {2, 3}
console.log(union)		// Set {1, 2, 3, 4}
console.log(difference)	// Set {1}
2. WeakSet
WeakSet 对象允许你将弱引用对象储存在一个集合中

WeakSet 与 Set 的区别：

WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以
WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素
属性：

constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数

const arr = [[1, 2], [3, 4]]
const weakset = new WeakSet(arr)
console.log(weakset)


方法：

add(value)：在WeakSet 对象中添加一个元素value
has(value)：判断 WeakSet 对象中是否包含value
delete(value)：删除元素 value
clear()：清空所有元素，注意该方法已废弃
var ws = new WeakSet()
var obj = {}
var foo = {}

ws.add(window)
ws.add(obj)

ws.has(window)	// true
ws.has(foo)	// false

ws.delete(window)	// true
ws.has(window)	// false
3. 字典（Map）
集合 与 字典 的区别：

共同点：集合、字典 可以储存不重复的值
不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存
const m = new Map()
const o = {p: 'haha'}
m.set(o, 'content')
m.get(o)	// content

m.has(o)	// true
m.delete(o)	// true
m.has(o)	// false
任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数，例如：

const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo') // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz') // 3
如果读取一个未知的键，则返回undefined。

new Map().get('asfddfsasadf')
// undefined
注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。

const map = new Map();

map.set(['a'], 555);
map.get(['a']) // undefined
上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。

由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。

let map = new Map();

map.set(-0, 123);
map.get(+0) // 123

map.set(true, 1);
map.set('true', 2);
map.get(true) // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined) // 3

map.set(NaN, 123);
map.get(NaN) // 123
Map 的属性及方法

属性：

constructor：构造函数

size：返回字典中所包含的元素个数

const map = new Map([
  ['name', 'An'],
  ['des', 'JS']
]);

map.size // 2
操作方法：

set(key, value)：向字典中添加新元素
get(key)：通过键查找特定的数值并返回
has(key)：判断字典中是否存在键key
delete(key)：通过键 key 从字典中移除对应的数据
clear()：将这个字典中的所有元素删除
遍历方法

Keys()：将字典中包含的所有键名以迭代器形式返回
values()：将字典中包含的所有数值以迭代器形式返回
entries()：返回所有成员的迭代器
forEach()：遍历字典的所有成员
const map = new Map([
            ['name', 'An'],
            ['des', 'JS']
        ]);
console.log(map.entries())	// MapIterator {"name" => "An", "des" => "JS"}
console.log(map.keys()) // MapIterator {"name", "des"}
Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。

map[Symbol.iterator] === map.entries
// true
Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。

对于 forEach ，看一个例子

const reporter = {
  report: function(key, value) {
    console.log("Key: %s, Value: %s", key, value);
  }
};

let map = new Map([
    ['name', 'An'],
    ['des', 'JS']
])
map.forEach(function(value, key, map) {
  this.report(key, value);
}, reporter);
// Key: name, Value: An
// Key: des, Value: JS
在这个例子中， forEach 方法的回调函数的 this，就指向 reporter

与其他数据结构的相互转换

Map 转 Array

const map = new Map([[1, 1], [2, 2], [3, 3]])
console.log([...map])	// [[1, 1], [2, 2], [3, 3]]
Array 转 Map

const map = new Map([[1, 1], [2, 2], [3, 3]])
console.log(map)	// Map {1 => 1, 2 => 2, 3 => 3}
Map 转 Object

因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。

function mapToObj(map) {
    let obj = Object.create(null)
    for (let [key, value] of map) {
        obj[key] = value
    }
    return obj
}
const map = new Map().set('name', 'An').set('des', 'JS')
mapToObj(map)  // {name: "An", des: "JS"}
Object 转 Map

function objToMap(obj) {
    let map = new Map()
    for (let key of Object.keys(obj)) {
        map.set(key, obj[key])
    }
    return map
}

objToMap({'name': 'An', 'des': 'JS'}) // Map {"name" => "An", "des" => "JS"}
Map 转 JSON

function mapToJson(map) {
    return JSON.stringify([...map])
}

let map = new Map().set('name', 'An').set('des', 'JS')
mapToJson(map)	// [["name","An"],["des","JS"]]
JSON 转 Map

function jsonToStrMap(jsonStr) {
  return objToMap(JSON.parse(jsonStr));
}

jsonToStrMap('{"name": "An", "des": "JS"}') // Map {"name" => "An", "des" => "JS"}
4. WeakMap
WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。

注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。

WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。

属性：

constructor：构造函数
方法：

has(key)：判断是否有 key 关联对象
get(key)：返回key关联对象（没有则则返回 undefined）
set(key)：设置一组key关联对象
delete(key)：移除 key 的关联对象
let myElement = document.getElementById('logo');
let myWeakmap = new WeakMap();

myWeakmap.set(myElement, {timesClicked: 0});

myElement.addEventListener('click', function() {
  let logoData = myWeakmap.get(myElement);
  logoData.timesClicked++;
}, false);
5. 总结
Set
成员唯一、无序且不重复
[value, value]，键值与键名是一致的（或者说只有键值，没有键名）
可以遍历，方法有：add、delete、has
WeakSet
成员都是对象
成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
不能遍历，方法有add、delete、has
Map
本质上是键值对的集合，类似集合
可以遍历，方法很多可以跟各种数据格式转换
WeakMap
只接受对象作为键名（null除外），不接受其他类型的值作为键名
键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
不能遍历，方法有get、set、has、delete
6. 扩展：Object与Set、Map
Object 与 Set

// Object
const properties1 = {
    'width': 1,
    'height': 1
}
console.log(properties1['width']? true: false) // true

// Set
const properties2 = new Set()
properties2.add('width')
properties2.add('height')
console.log(properties2.has('width')) // true
Object 与 Map

JS 中的对象（Object），本质上是键值对的集合（hash 结构）

const data = {};
const element = document.getElementsByClassName('App');

data[element] = 'metadata';
console.log(data['[object HTMLCollection]']) // "metadata"
但当以一个DOM节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 字符串-值 对应，Map则提供了 值-值 的对应

['1', '2', '3'].map(parseInt) what & why ? 
第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。

首先让我们回顾一下，map函数的第一个参数callback：
var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])
这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。

而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。
parseInt(string, radix)
接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。

了解这两个函数后，我们可以模拟一下运行情况

parseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1
parseInt('2', 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN
parseInt('3', 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN
map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]

防抖
触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间

思路：
每次触发事件时都取消之前的延时调用方法

function debounce(fn) {
      let timeout = null; // 创建一个标记用来存放定时器的返回值
      return function () {
        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
        timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
          fn.apply(this, arguments);
        }, 500);
      };
    }
    function sayHi() {
      console.log('防抖成功');
    }

    var inp = document.getElementById('inp');
    inp.addEventListener('input', debounce(sayHi)); // 防抖
节流
高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

思路：
每次触发事件时都判断当前是否有等待执行的延时函数

function throttle(fn) {
      let canRun = true; // 通过闭包保存一个标记
      return function () {
        if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
        canRun = false; // 立即设置为false
        setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
          fn.apply(this, arguments);
          // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
          canRun = true;
        }, 500);
      };
    }
    function sayHi(e) {
      console.log(e.target.innerWidth, e.target.innerHeight);
    }
    window.addEventListener('resize', throttle(sayHi));

常见异步笔试题，请写出代码的运行结果
//请写出输出内容
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
	console.log('async2');
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0)

async1();

new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');


/*
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
*/

将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组
Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b})

arr.toString().split(",").sort((a,b)=>{ return a-b})

Array.prototype.flat= function() {
    return [].concat(...this.map(item => (Array.isArray(item) ? item.flat() : [item])));
}
Array.prototype.unique = function() {
    return [...new Set(this)]
}
const sort = (a, b) => a - b;
console.log(arr.flat().unique().sort(sort)); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 ]

var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr);
    }
    return arr;
}
Array.from(new Set(flatten(arr))).sort((a, b) => {
 return a - b
})

简单讲解一下 http2 的多路复用
在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：

第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。
HTTP/2的多路复用就是为了解决上述的两个性能问题。
在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。
帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

一、三次握手讲解
客户端发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，服务器由SYN=1知道客户端要求建立联机（客户端：我要连接你）
服务器收到请求后要确认联机信息，向A发送ack number=(客户端的seq+1),syn=1,ack=1,随机产生seq=7654321的包（服务器：好的，你来连吧）
客户端收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，客户端会再发送ack number=(服务器的seq+1),ack=1，服务器收到后确认seq值与ack=1则连接建立成功。（客户端：好的，我来了）
二、为什么http建立连接需要三次握手，不是两次或四次?
答：三次是最少的安全次数，两次不安全，四次浪费资源；

三、TCP关闭连接过程
Client向Server发送FIN包，表示Client主动要关闭连接，然后进入FIN_WAIT_1状态，等待Server返回ACK包。此后Client不能再向Server发送数据，但能读取数据。

Server收到FIN包后向Client发送ACK包，然后进入CLOSE_WAIT状态，此后Server不能再读取数据，但可以继续向Client发送数据。

Client收到Server返回的ACK包后进入FIN_WAIT_2状态，等待Server发送FIN包。

Server完成数据的发送后，将FIN包发送给Client，然后进入LAST_ACK状态，等待Client返回ACK包，此后Server既不能读取数据，也不能发送数据。

Client收到FIN包后向Server发送ACK包，然后进入TIME_WAIT状态，接着等待足够长的时间（2MSL）以确保Server接收到ACK包，最后回到CLOSED状态，释放网络资源。

Server收到Client返回的ACK包后便回到CLOSED状态，释放网络资源。

四、为什么要四次挥手？
TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道，通道1:客户端的输出连接服务端的输入；通道2:客户端的输入连接服务端的输出。两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：

客户端：我要关闭输入通道了。
服务端：好的，你关闭吧，我这边也关闭这个通道。

服务端：我也要关闭输入通道了。
客户端：好的你关闭吧，我也把这个通道关闭。

在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。

**原因：**在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。
对于异步渲染，我们应在 getSnapshotBeforeUpdate 中读取 state、props, 而不是 componentWillUpdate。但调用forceUpdate() 强制 render 时，会导致组件跳过 shouldComponentUpdate(),直接调用 render()。（https://github.com/sisterAn/blog/issues/26）

promise构造函数是同步执行的，then方法是异步执行的
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve(5);
  console.log(2);
}).then(val => {
  console.log(val);
});

promise.then(() => {
  console.log(3);
});

console.log(4);

setTimeout(function() {
  console.log(6);
});
执行结果: 124536

ES5/ES6 的继承除了写法以外还有什么区别
class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
const bar = new Bar(); // it's ok
function Bar() {
  this.bar = 42;
}

const foo = new Foo(); // ReferenceError: Foo is not defined
class Foo {
  constructor() {
    this.foo = 42;
  }
}
class 声明内部会启用严格模式。
// 引用一个未声明的变量
function Bar() {
  baz = 42; // it's ok
}
const bar = new Bar();

class Foo {
  constructor() {
    fol = 42; // ReferenceError: fol is not defined
  }
}
const foo = new Foo();
class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
// 引用一个未声明的变量
function Bar() {
  this.bar = 42;
}
Bar.answer = function() {
  return 42;
};
Bar.prototype.print = function() {
  console.log(this.bar);
};
const barKeys = Object.keys(Bar); // ['answer']
const barProtoKeys = Object.keys(Bar.prototype); // ['print']

class Foo {
  constructor() {
    this.foo = 42;
  }
  static answer() {
    return 42;
  }
  print() {
    console.log(this.foo);
  }
}
const fooKeys = Object.keys(Foo); // []
const fooProtoKeys = Object.keys(Foo.prototype); // []
class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。
function Bar() {
  this.bar = 42;
}
Bar.prototype.print = function() {
  console.log(this.bar);
};

const bar = new Bar();
const barPrint = new bar.print(); // it's ok

class Foo {
  constructor() {
    this.foo = 42;
  }
  print() {
    console.log(this.foo);
  }
}
const foo = new Foo();
const fooPrint = new foo.print(); // TypeError: foo.print is not a constructor
必须使用 new 调用 class。
function Bar() {
  this.bar = 42;
}
const bar = Bar(); // it's ok

class Foo {
  constructor() {
    this.foo = 42;
  }
}
const foo = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new'
class 内部无法重写类名。
function Bar() {
  Bar = 'Baz'; // it's ok
  this.bar = 42;
}
const bar = new Bar();
// Bar: 'Baz'
// bar: Bar {bar: 42}  

class Foo {
  constructor() {
    this.foo = 42;
    Foo = 'Fol'; // TypeError: Assignment to constant variable
  }
}
const foo = new Foo();
Foo = 'Fol'; // it's ok

ES5 和 ES6 子类 this 生成顺序不同。ES5 的继承先生成了子类实例，再调用父类的构造函数修饰子类实例，ES6 的继承先生成父类实例，再调用子类的构造函数修饰父类实例。这个差别使得 ES6 可以继承内置对象。

问题是继承的差异。

class Super {}
class Sub extends Super {}

const sub = new Sub();

Sub.__proto__ === Super;
子类可以直接通过 __proto__ 寻址到父类。

function Super() {}
function Sub() {}

Sub.prototype = new Super();
Sub.prototype.constructor = Sub;

var sub = new Sub();

Sub.__proto__ === Function.prototype;
而通过 ES5 的方式，Sub.__proto__ === Function.prototype

1. Object.prototype.toString.call()
每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用call或者apply方法来改变toString方法的执行上下文。//类似于"[object String]"

const an = ['Hello','An'];
an.toString(); // "Hello,An"
Object.prototype.toString.call(an); // "[object Array]"
这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。

Object.prototype.toString.call('An') // "[object String]"
Object.prototype.toString.call(1) // "[object Number]"
Object.prototype.toString.call(Symbol(1)) // "[object Symbol]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(undefined) // "[object Undefined]"
Object.prototype.toString.call(function(){}) // "[object Function]"
Object.prototype.toString.call({name: 'An'}) // "[object Object]"
Object.prototype.toString.call() 常用于判断浏览器内置对象时。

更多实现可见 谈谈 Object.prototype.toString

2. instanceof
instanceof  的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。

使用 instanceof判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。

[]  instanceof Array; // true
但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。

[]  instanceof Object; // true
3. Array.isArray()
功能：用来判断对象是否为数组

instanceof 与 isArray

当检测Array实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes

var iframe = document.createElement('iframe');
document.body.appendChild(iframe);
xArray = window.frames[window.frames.length-1].Array;
var arr = new xArray(1,2,3); // [1,2,3]

// Correctly checking for Array
Array.isArray(arr);  // true
Object.prototype.toString.call(arr); // true
// Considered harmful, because doesn't work though iframes
arr instanceof Array; // false
Array.isArray() 与 Object.prototype.toString.call()

Array.isArray()是ES5新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。

if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
Object.prototype.toString.call()这个方法也不是完全靠谱的啊，
如果遇到对象的属性 Symbol.toStringTag 被改成了"Array" 怎么办啊
应该要加上instanceof和typeof三重判断才行

介绍下重绘和回流（Repaint & Reflow），以及如何进行优化
1. 浏览器渲染机制
浏览器采用流式布局模型（Flow Based Layout）
浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree）。
有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。
2. 重绘
由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。

3. 回流
回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。

<body>
<div class="error">
    <h4>我的组件</h4>
    <p><strong>错误：</strong>错误的描述…</p>
    <h5>错误纠正</h5>
    <ol>
        <li>第一步</li>
        <li>第二步</li>
    </ol>
</div>
</body>
在上面的HTML片段中，对该段落(<p>标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（div.error和body – 视浏览器而定）。此外，<h5>和<ol>也会有简单的回流，因为其在DOM中在回流元素之后。大部分的回流将导致页面的重新渲染。

回流必定会发生重绘，重绘不一定会引发回流。

4. 浏览器优化
现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。

主要包括以下属性或方法：

offsetTop、offsetLeft、offsetWidth、offsetHeight
scrollTop、scrollLeft、scrollWidth、scrollHeight
clientTop、clientLeft、clientWidth、clientHeight
width、height
getComputedStyle()
getBoundingClientRect()
所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。

5. 减少重绘与回流
CSS

使用 transform 替代 top

使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局

避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。

尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。

避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。

<div>
  <a> <span></span> </a>
</div>
<style>
  span {
    color: red;
  }
  div > a > span {
    color: red;
  }
</style>
对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。

将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。

避免使用CSS表达式，可能会引发回流。

将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。

CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

JavaScript

避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

观察者模式中主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知
在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。
在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。

观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。

观察者 模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。

关于 const 和 let 声明的变量不在 window 上 
在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中
怎么获取？在定义变量的块级作用域中就能获取啊，既然不属于顶层对象，那就不加 window（global）呗。
let aa = 1;
const bb = 2;
console.log(aa); // 1
console.log(bb); // 2


cookie 和 token 都存放在 header 中，为什么不会劫持 token？
1、首先token不是防止XSS的，而是为了防止CSRF的；
2、CSRF攻击的原因是浏览器会自动带上cookie，而浏览器不会自动带上token

setTimeout、Promise、Async/Await 的区别
这题怎么没人答，我说下我粗浅的认识，抛砖引玉，欢迎指正和补充。
我觉得这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。
其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；
promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。

聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的
核心是利用ES5的Object.defineProperty,这也是Vue.js为什么不能兼容IE8及以下浏览器的原因。

Object.defineProperty方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。
Object.defineProperty(
obj, // 定义属性的对象
prop, // 要定义或修改的属性的名称
descriptor, // 将被定义或修改属性的描述符【核心】

observe的功能就是用来监测数据的变化。实现方式是给非VNode的对象类型数据添加一个Observer,如果已经添加过则直接返回，否则在满足一定条件下去实例化一个Observer对象实例。
Observer是一个类,它的作用是给对象属性添加getter和setter,用于 依赖收集 和 派发更新

依赖收集getter（重点关注以下两点）

*const dep = new Dep() // 实例化一个Dep实例
*在get函数中通过dep.depend做依赖收集
Dep是一个Class,它定义了一些属性和方法，它有一个静态属性target，这是一个全局唯一Watcher【同一时间内只能有一个全局的Watcher被计算】。Dep实际上就是对Watcher的一种管理，Dep脱离Watcher单独存在是没有意义的。Watcher和Dep就是典型的观察者设计模式。

Watcher是一个Class,在它的构造函数中定义了一些和Dep相关的属性：

this.deps = []
this.newDeps = []
this.depIds = new Set()
this.newDepIds = new Set()				
收集过程：当我们实例化一个渲染watcher的时候，首先进入watcher的构造函数逻辑，然后执行他的this.get()方法，进入get函数把Dep.target赋值为当前渲染watcher并压栈（为了恢复用）。接着执行vm._render()方法，生成渲染VNode,并且在这个过程对vm上的数据访问，这个时候就触发数据对象的getter（在此期间执行Dep.target.addDep(this)方法，将watcher订阅到这个数据持有的dep的subs中，为后续数据变化时通知到哪些subs做准备）。然后递归遍历添加所有子项的getter。

Watcher在构造函数中初始化两个Dep实例数组。newDeps代表新添加的Dep实例数组，deps代表上一次添加的Dep实例数组。
依赖清空：在执行清空依赖（cleanupDeps）函数时，会首先遍历deps,移除对dep的订阅，然后把newDepsIds和depIds交换，newDeps和deps交换，并把newDepIds和newDeps清空。考虑场景，在条件渲染时，及时对不需要渲染数据的订阅移除，减少性能浪费。

考虑到Vue是数据驱动的，所以每次数据变化都会重写Render,那么vm._render()方法会再次执行，并再次触发数据

收集依赖的目的是为了当这些响应式数据发生变化，触发它们的setter的时候，能知道应该通知哪些订阅者去做相应的逻辑处理【派发更新】

派发更新setter（重点关注以下两点）

*childOb = !shallow && observe(newVal) // 如果shallow为false的情况，会对新设置的值变成一个响应式对象
*dep.notify() // 通知所有订阅者
派发过程：当我们组件中对响应的数据做了修改，就会触发setter的逻辑，最后调用dep.notify()方法，它是Dep的一个实例方法。具体做法是遍历依赖收集中建立的subs，也就是Watcher的实例数组【subs数组在依赖收集getter中被添加，期间通过一些逻辑处理判断保证同一数据不会被添加多次】，然后调用每一个watcher的update方法。

update函数中有个queueWatcher(this)方法引入了队列的概念，是vue在做派发更新时优化的一个点，它并不会每次数据改变都会触发watcher回调，而是把这些watcher先添加到一个队列中，然后在nextTick后执行watcher的run函数

队列排序保证：

组件的更新由父到子。父组件创建早于子组件，watcher的创建也是
用户自定义watcher要早于渲染watcher执行，因为用户自定义watcher是在渲染watcher前创建的
如果一个组件在父组件watcher执行期间被销毁，那么它对应的watcher执行都可以被跳过，所以父组件的watcher应该先执行。
队列遍历：排序完成后，对队列进行遍历，拿到对应的watcher,执行watcher.run()。
run函数解析：先通过this.get()得到它当前的值，然后做判断，如果满足新旧值不等、新值是对象类型、deep模式任何一个条件，则执行watcher的回调，注意回调函数执行的时候会把第一个参数和第二个参数传入新值value和旧值oldValue，这就是当我们自己添加watcher时候可以在参数中取到新旧值的来源。对应渲染watcher而言，在执行this.get()方法求值的时候，会执行getter方法。因此在我们修改组件相关数据时候，会触发组件重新渲染，接着重新执行patch的过程

手写一个数据绑定：
<input id="input" type="text" />
<div id="text"></div>

let input = document.getElementById("input");
let text = document.getElementById("text");
let data = { value: "" };
Object.defineProperty(data, "value", {
  set: function(val) {
    text.innerHTML = val;
    input.value = val;
  },
  get: function() {
    return input.value;
  }
});
input.onkeyup = function(e) {
  data.value = e.target.value;
};


let a1 =  ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
let a2 = ['A', 'B', 'C', 'D'].map((item) => {
  return item + 3
})

请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]
let a3 = [...a1, ...a2].sort().map((item) => {
  if(item.includes('3')){
    return item.split('')[0]
  }
  return item
})

聊聊 Redux 和 Vuex 的设计思想
https://zhuanlan.zhihu.com/p/53599723

改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。
for (var i = 0; i< 10; i++){
   setTimeout((i) => {
   console.log(i);
   }, 1000,i)
}
这是每隔一秒输出0-9
for (var i = 0; i< 10; i++){
   setTimeout((i) => {
   console.log(i);
   }, 1000*i,i)
}

for (var i = 0; i< 10; i++){
  ((i) => {
    setTimeout(() => {
      console.log(i);
    }, 1000)
 })(i)
}

for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000)
}

var b = 10;
(function b() {
  b = 20;
  console.log(b)
})()
打印什么？
1打印结果内容如下：
ƒ b() {
b = 20;
console.log(b)
}
2原因：
作用域：执行上下文中包含作用于链：
在理解作用域链之前，先介绍一下作用域，作用域可以理解为执行上下文中申明的变量和作用的范围；包括块级作用域/函数作用域；
特性：声明提前：一个声明在函数体内都是可见的，函数声明优先于变量声明；
在非匿名自执行函数中，函数变量为只读状态无法修改；
b函数是一个相当于用const定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错"Uncaught TypeError: Assignment to constant variable."
var b = 10;
(function b() {
  'use strict'
  b = 20;
  console.log(b)
})() // "Uncaught TypeError: Assignment to constant variable."

简单改造下面的代码，使之分别打印 10 和 20。
var b = 10;
(function b(){
   b = 20;
   console.log(b); 
})();

var b = 10;
(function b(b) {
    window.b = 20;
    console.log(window.b);
    console.log(b);
})(b);

请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中？
https://juejin.im/post/5c22ee806fb9a049fb43b2c5?utm_source=gold_browser_extension

使用迭代的方式实现 flatten 函数
let arr = [1, 2, [3, 4, 5, [6, 7], 8], 9, 10, [11, [12, 13]]]

let arr1 = arr.toString().split(",").map(val =>parseInt(val));
console.log(arr1); 

const flatten = function (arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr)
    }
    return arr
}

console.log(flatten(arr))

const flatten = array => array.reduce((acc, cur) => (Array.isArray(cur) ? [...acc, ...flatten(cur)] : [...acc, cur]), [])

下面代码中 a 在什么情况下会打印 1？
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	conso.log(1);
}
 因为==会进行隐式类型转换 所以我们重写toString方法就可以了
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}
if( a == 1 && a == 2 && a == 3 ) {
  console.log(1);
}

let a = [1,2,3];
a.toString = a.shift;
if( a == 1 && a == 2 && a == 3 ) {
  console.log(1);
}

介绍下 BFC 及其应用
BFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。创建 BFC 的方式有：
html 根元素
float 浮动
绝对定位
overflow 不为 visiable
display 为表格布局或者弹性布局
BFC 主要的作用是：
清除浮动
防止同一 BFC 容器中的相邻元素间的外边距重叠问题

在 Vue 中，子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的。？
子组件为何不可以修改父组件传递的 Prop
单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。
如果修改了，Vue 是如何监控到属性的修改并给出警告的。

然而 props传入的是对象的话 是可以直接在子组件里更改的, 因为是同一个引用
组件对于data的监听是深度监听
而对于props的监听是浅度监听
需要特别注意的是，当你从子组件修改的prop属于基础类型时会触发提示。 这种情况下，你是无法修改父组件的数据源的， 因为基础类型赋值时是值拷贝。你直接将另一个非基础类型（Object, array）赋值到此key时也会触发提示(但实际上不会影响父组件的数据源)， 当你修改object的属性时不会触发提示，并且会修改父组件数据源的数据。
vue如何知道修改了父组件传来的props？

下面的代码就是实现Vue提示修改props的操作，在组件 initProps 方法的时候，会对props进行defineReactive操作，传入的第四个参数是自定义的set函数，该函数会在触发props的set方法时执行，当props修改了，就会运行这里传入的第四个参数，然后进行判断，如果不是root根组件，并且不是更新子组件，那么说明更新的是props，所以会警告

// src/core/instance/state.js 源码路径
defineReactive(props, key, value, () => {
  if (!isRoot && !isUpdatingChildComponent) {
    warn(
      `Avoid mutating a prop directly since the value will be ` +
      `overwritten whenever the parent component re-renders. ` +
      `Instead, use a data or computed property based on the prop's ` +
      `value. Prop being mutated: "${key}"`,
      vm
    )
  }
})

考察作用域的一道代码题
var a = 10;
(function () {
	console.log(a)
	a = 5
	console.log(window.a)
	var a = 20
	console.log(a)
})()
执行解析步骤：
var a = undefined;
a = 10;
(function () {
// 变量提升（预解析）
var a = undefined;
console.log(a); // 输出undefined
a = 5;
console.log(window.a); // 找window(全局)对象的a, 输出10
a = 20;
console.log(a); // 输出20
})()

实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现 
//Promise
const sleep = time => {
  return new Promise(resolve => setTimeout(resolve,time))
}
sleep(1000).then(()=>{
  console.log(1)
})

//Generator
function* sleepGenerator(time) {
  yield new Promise(function(resolve,reject){
    setTimeout(resolve,time);
  })
}
sleepGenerator(1000).next().value.then(()=>{console.log(1)})

//async
function sleep(time) {
  return new Promise(resolve => setTimeout(resolve,time))
}
async function output() {
  let out = await sleep(1000);
  console.log(1);
  return out;
}
output();

//ES5
function sleep(callback,time) {
  if(typeof callback === 'function')
    setTimeout(callback,time)
}

function output(){
  console.log(1);
}
sleep(output,1000);

为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作
因为更改state的函数必须是纯函数，纯函数既是统一输入就会统一输出，没有任何副作用；如果是异步则会引入额外的副作用，导致更改后的state不可预测；

使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果

原题目：
使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果
我的答案：
[102, 15, 22, 29, 3, 8]
解析：
根据MDN上对Array.sort()的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的UTF-16编码顺序来进行排序。所以'102' 会排在 '15' 前面。以下是MDN中的解释原文：
The sort() method sorts the elements of an array in place and returns the array. The default sort order is built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.

输出以下代码执行的结果并解释为什么 
var obj = {
    '2': 3,
    '3': 4,
    'length': 2,
    'splice': Array.prototype.splice,
    'push': Array.prototype.push
}
obj.push(1)
obj.push(2)
console.log(obj)
涉及知识点：

类数组（ArrayLike）：
一组数据，由数组来存，但是如果要对这组数据进行扩展，会影响到数组原型，ArrayLike的出现则提供了一个中间数据桥梁，ArrayLike有数组的特性， 但是对ArrayLike的扩展并不会影响到原生的数组。

push方法：
push 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。
唯一的原生类数组（array-like）对象是 Strings，尽管如此，它们并不适用该方法，因为字符串是不可改变的。

对象转数组的方式：
Array.from()、splice()、concat()等
题分析：
这个obj中定义了两个key值，分别为splice和push分别对应数组原型中的splice和push方法，因此这个obj可以调用数组中的push和splice方法，调用对象的push方法：push(1)，因为此时obj中定义length为2，所以从数组中的第二项开始插入，也就是数组的第三项（下表为2的那一项），因为数组是从第0项开始的，这时已经定义了下标为2和3这两项，所以它会替换第三项也就是下标为2的值，第一次执行push完，此时key为2的属性值为1，同理：第二次执行push方法，key为3的属性值为2。此时的输出结果就是：
Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]---->
[
2: 1,
3: 2,
length: 4,
push: ƒ push(),
splice: ƒ splice()
]

因为只是定义了2和3两项，没有定义0和1这两项，所以前面会是empty。
如果讲这道题改为：

var obj = {
    '2': 3,
    '3': 4,
    'length': 0,
    'splice': Array.prototype.splice,
    'push': Array.prototype.push
}
obj.push(1)
obj.push(2)
console.log(obj)
此时的打印结果就是：
Object(2) [1, 2, 2: 3, 3: 4, splice: ƒ, push: ƒ]---->
[
0: 1,
1: 2,
2: 3,
3: 4,
length: 2,
push: ƒ push(),
splice: ƒ splice()
]

原理：此时length长度设置为0，push方法从第0项开始插入，所以填充了第0项的empty
至于为什么对象添加了splice属性后并没有调用就会变成类数组对象这个问题，这是控制台中 DevTools 猜测类数组的一个方式：
***重点***只要一个对象的 length 属性为数字，同时splice属性为函数时， 对象的函数输出结果就会变成 伪数组。

双向绑定和 vuex 是否冲突 
在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误。当需要在组件中使用vuex中的state时，有2种解决方案：
1、在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值
2、使用带有setter的双向绑定计算属性。见以下例子（来自官方文档）：
<input v-model="message">
computed: { message: { get () { return this.$store.state.obj.message }, set (value) { this.$store.commit('updateMessage', value) } } }

call 和 apply 的区别是什么，哪个性能更好一些
Function.prototype.apply和Function.prototype.call 的作用是一样的，区别在于传入参数的不同；
第一个参数都是，指定函数体内this的指向；
第二个参数开始不同，apply是传入带下标的集合，数组或者类数组，apply把它传给函数作为参数，call从第二个开始传入的参数是不固定的，都会传给函数作为参数。
call比apply的性能要好，平常可以多用call, call传入参数的格式正是内部所需要的格式

尤其是es6 引入了 Spread operator (延展操作符) 后，即使参数是数组，可以使用 call
let params = [1,2,3,4]
xx.call(obj, ...params)

call 比 apply 的性能好, 我的理解是内部少了一次将 apply 第二个参数解构的操作

实现 (5).add(3).minus(2) 功能
Number.prototype.add = function(n) {
  return this.valueOf() + n;
};
Number.prototype.minus = function(n) {
  return this.valueOf() - n;
};

Number.prototype.add =  function(n){
  return this + n
}
Number.prototype.minus =  function(n){
  return this - n
}
console.log((5).add(3).minus(2))//6


浮点数陷阱
toPrecision vs toFixed
数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。注意在计算的中间过程不要使用，只用于最终结果。

不同点就需要注意一下：

toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。
toFixed 是小数点后指定位数取整，从小数点开始数起。
两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。

如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。

原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！

解法：使用专业的四舍五入函数 Math.round() 来处理。但 Math.round(1.005 * 100) / 100 还是不行，因为 1.005 * 100 = 100.49999999999999。还需要把乘法和除法精度误差都解决后再使用 Math.round。可以使用后面介绍的 number-precision#round 方法来解决。

解决方案
回到最关心的问题：如何解决浮点误差。首先，理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果。

数据展示类
当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：

parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True
封装成方法就是：

function strip(num, precision = 12) {
  return +parseFloat(num.toPrecision(precision));
}
为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。

数据运算类
对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：

/**
 * 精确加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
以上方法能适用于大部分场景。遇到科学计数法如 2.3e+1（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。

能读到这里，说明你非常有耐心，那我就放个福利吧。遇到浮点数误差问题时可以直接使用
https://github.com/dt-fe/number-precision

完美支持浮点数的加减乘除、四舍五入等运算。非常小只有1K，远小于绝大多数同类库（如Math.js、BigDecimal.js），100%测试全覆盖，代码可读性强，不妨在你的应用里用起来！

为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

英文术语叫：image beacon
没有跨域问题，一般这种上报数据，代码要写通用的；（排除ajax）
不会阻塞页面加载，影响用户的体验，只要new Image对象就好了；（排除JS/CSS文件资源方式上报）
在所有图片中，体积最小；（比较PNG/JPG）
能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
跨域友好
执行过程无阻塞
相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）

Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？
Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。
Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。

怎么让一个 div 水平垂直居中
<div class="parent">
  <div class="child"></div>
</div>
1.
div.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
2.
div.parent {
    position: relative; 
}
div.child {
    position: absolute; 
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);  
}
/* 或者 */
div.child {
    width: 50px;
    height: 10px;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -25px;
    margin-top: -5px;
}
/* 或 */
div.child {
    width: 50px;
    height: 10px;
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}
3.
div.parent {
    display: grid;
}
div.child {
    justify-self: center;
    align-self: center;
}
4.
div.parent {
    font-size: 0;
    text-align: center;
    &::before {
        content: "";
        display: inline-block;
        width: 0;
        height: 100%;
        vertical-align: middle;
    }
}
div.child{
  display: inline-block;
  vertical-align: middle;
}
5.
div.parent{
  display:flex;
}
div.child{
  margin:auto;
}

输出以下代码的执行结果并解释为什么
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

console.log(a.x) 	
console.log(b.x)
结果:
undefined
{n:2}

首先，a和b同时引用了{n:2}对象，接着执行到a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的{n:1}对象新增了一个属性x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行a ={n:2}的时候，a的引用改变，指向了新对象{n：2},而b依然指向的是旧对象。之后执行a.x = {n：2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被b引用着。
后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即{n:2}。
注意点：
1: 点的优先级大于等号的优先级
2: 对象以指针的形式进行存储，每个新对象都是一份新的存储地址

var a = {n: 1}; // a保持对{n:1}对象的引用
var b = a; // b保持对{n:1}对象的引用
a.x = a = {n: 2}; // a的引用被改变
a.x 	// --> undefined
b.x 	// --> {n: 2}
1、.运算符优先，a.x此时保持对{n: 1}的引用，也就是b也保持对{n: 1}的引用，于是{n: 1} => {n: 1, x: undefined}，此时a和b还是对原来对象的引用，只不过原来对象增加了x属性
2、=从右往左，a = {n: 2}，此时a的引用已经变成了{n: 2}这个对象
3、a.x=a，此时a.x是保持对{ n: 1, x: undefined}中的x引用，也就是b.x，于是{ n: 1, x: undefined} => {n: 1, x: { n: 2}}，即b.x = { n: 2 }

某公司 1 到 12 月份的销售额存在一个对象里面
let obj = {1:222, 2:123, 5:888};

const result = Array.from({ length: 12 }).map((_, index) => obj[index + 1] || null);
console.log(result)//[222, 123, null, null, 888, null, null, null, null, null, null, null]

Array.from({length:12},(v,i)=>({1:222,2:123,5:888}[i+1])||null)

冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？
function bubbleSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    console.log(arr);
}

// 改进冒泡排序 每次最大值放到最右后，会将本轮最后一个操作的位置作为下一轮的终点，可以减少不必要的一些冒泡
function bubbleSort1(arr) {
    let i = arr.length - 1;

    while (i > 0) {
        let pos = 0;
        for (let j = 0; j < i; j++) { //这里的i会变成最后一次操作的位置
            if (arr[j] > arr[j + 1]) {
                pos = j;
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        i = pos;
    }
    console.log(arr);
}

要求设计 LazyMan 类，实现以下功能。
LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony').sleep(10).eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
Answer

class LazyManClass {
    constructor(name) {
        this.taskList = [];
        this.name = name;
        console.log(`Hi I am ${this.name}`);
        setTimeout(() => {
            this.next();
        }, 0);
    }
    eat (name) {
        var that = this;
        var fn = (function (n) {
            return function () {
                console.log(`I am eating ${n}`)
                that.next();
            }
        })(name);
        this.taskList.push(fn);
        return this;
    }
    sleepFirst (time) {
        var that = this;
        var fn = (function (t) {
            return function () {
                setTimeout(() => {
                    console.log(`等待了${t}秒...`)
                    that.next();
                }, t * 1000);  
            }
        })(time);
        this.taskList.unshift(fn);
        return this;
    }
    sleep (time) {
        var that = this
        var fn = (function (t) {
            return function () {
                setTimeout(() => {
                    console.log(`等待了${t}秒...`)
                    that.next();
                }, t * 1000); 
            }
        })(time);
        this.taskList.push(fn);
        return this;
    }
    next () {
        var fn = this.taskList.shift();
        fn && fn();
    }
}
function LazyMan(name) {
    return new LazyManClass(name);
}
LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(4).eat('junk food');

分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景
display: none (不占空间，不能点击)（场景，显示出原来这里不存在的结构）
visibility: hidden（占据空间，不能点击）（场景：显示不会导致页面结构发生变动，不会撑开）
opacity: 0（占据空间，可以点击）（场景：可以跟transition搭配）
display: none 会回流操作 性能开销较大，
visibility: hidden 是重回操作 比回流操作性能高一些，（回流会计算相邻元素甚至组先级元素的位置，属性等）
opacity: 0 重建图层，性能较高
补充：株连性
如果祖先元素遭遇某祸害，则其子孙孙无一例外也要遭殃，比如：
opacity:0和display:none，若父节点元素应用了opacity:0和display:none，无论其子孙元素如何挣扎都不会再出现在大众视野；
而若父节点元素应用visibility:hidden，子孙元素应用visibility:visible，那么其就会毫无意外的显现出来。
总结一下：
结构：
display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，
visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击
opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击

继承：
display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。
visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。

性能：
displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大
visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容
opacity: 0 ： 修改元素会造成重绘，性能消耗较少
联系：它们都能让元素不可见


箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：
1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
4、不可以使用 new 命令，因为：

箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么
没有自己的 this，无法调用 call，apply。
没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 __proto__
new 过程大致是这样的：
function newFunc(father, ...rest) {
  var result = {};
  result.__proto__ = father.prototype;
  var result2 = father.apply(result, rest);
  if (
    (typeof result2 === 'object' || typeof result2 === 'function') &&
    result2 !== null
  ) {
    return result2;
  }
  return result;
}

第 59 题：给定两个数组，写一个方法来计算它们的交集。 
给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。
const intersect = (nums1, nums2) => {
  const map = {}
  const res = []
  for (let n of nums1) {
    if (map[n]) {
      map[n]++
    } else {
      map[n] = 1
    }
  }
  for (let n of nums2) {
    if (map[n] > 0) {
      res.push(n)
      map[n]--
    }
  }
  return res
}

已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改
<img src="1.jpg" style="width:480px!important;”>

<img src="1.jpg" style="width:480px!important; max-width: 300px">
<img src="1.jpg" style="width:480px!important; transform: scale(0.625, 1);" >
<img src="1.jpg" style="width:480px!important; width:300px!important;">
1.css方法
max-width:300px;覆盖其样式；
transform: scale(0.625)；按比例缩放图片；
2.js方法
document.getElementsByTagName("img")[0].setAttribute("style","width:300px!important;")
总结一下
1、给图片设置max-width:300px
2、给图片设置transform: scale(0.625,0.625)，但是占据的位置还是原来的480px
3、给图片设置box-sizing: border-box;padding: 0 90px;，但图片左右会有90px的内边距
4、给图片设置zoom: 0.625
5、js获取元素使用imgs[0].setAttribute("style","width:300px!important;")或者imgs[0].style.cssText='width:300px;'
6、给图片设置动画，from{width:300px;}to{width:300px;}，动画时间为0s，原理是CSS动画的样式优先级高于!important的特性

介绍下如何实现 token 加密？
jwt举例

需要一个secret（随机数）
后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端
前端每次request在header中带上token
后端用同样的算法解密

redux 为什么要把 reducer 设计成纯函数 ？
首先命题应当改一下，中文有歧义，可能改为 “redux中的reducer为什么必须（最好）是纯函数“，我想表达的意思是，redux没有强制你reducer是个纯函数，事实上，没有人能通过框架限制判断一个函数是否是纯函数，所以题目中的'设计成'这个短语貌似在说redux已经把reducer强制规定是纯函数了。这回让你怀疑你对redux的认知。

正文如下
然后说一下为什么reducer最好是纯函数，首先你得看看文档怎么说reducer的作用的，‘接收旧的 state 和 action，返回新的 state’，您可得瞧好咯，他就是起一个对数据做简单处理后返回state的作用，为什么只起这个作用，这时用设计这个词回答这个问题才恰当，因为redux把reducer设计成只负责这个作用。很白痴的问答对吧，所以题目的答案也就简单了，reducer的职责不允许有副作用，副作用简单来说就是不确定性，如果reducer有副作用，那么返回的state就不确定，举个例子，你的reducer就做了一个value = value + 1这个逻辑，然后返回state为{value}，ok，这个过程太jr纯了，然后你可能觉得要加个请求来取得value后再加1，那么你的逻辑就是value = getValue() + 1, getValue是个请求函数，返回一个值，这种情况，退一万步讲，如果你的网络请求这次出错，那么getValue就返回的不是一个数值，value就不确定了，所以return的state你也不确定了，前端UI拿到的数据也不确定了，所以就是这个环节引入了副作用，他娘的redux设计好的规范就被你破坏了，redux就没卵用了。到此为止这个问题回答完了，我没有说什么上面几个jr说的教科书的理论，甚至还加了些脏话。请原谅，这只是戏剧需要。

最后我回答下如何解决这个副作用，实际上也很白痴的问题，这里的请求可以放在reducer之前，你先请求，该做出错处理的就做出错处理，等拿到实际数据后在发送action来调用reducer。这样通过前移副作用的方式，使reducer变得纯洁。

如何设计实现无缝轮播？
这里说一个不需要clone的方案：

<div class="slide">
  <ul>
    <li>图片1</li>
    <li>图片2</li>
   <li>图片3</li>
  </ul>
</div>
1、最外层div.slide定宽、相对定位relative

2、ul 足够宽，最起码li数*li宽度，这里有个技巧，直接 width: 9999em，目的是让里面的所有li一字排开

3、滚动效果通过控制ul的left或者transform来进行滚动效果

4、到了最后一个li，往后看第一个li的时：

4.1、准备继续滚动，把最后一个的li设置为相对定位relative，left值为此时此刻相对ul的位置（设置的时候不要带缓动效果），目的是让最后一个li不动。

4.2、然后把ul的left或者transform设为0（这步没有缓动效果），

4.3、然后再正常的开始一样出现第一个li的滚动效果（这步有缓动效果）

4.4、最后等无缝的第一个li效果完成后，把最后一个li的left值复原为0

5、到第一个li，往前看最后一个li时，也是和上面同理
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>轮播</title>
    <style>
        *{
            padding: 0;
            margin: 0;
            list-style: none;
        }
        #continer{
            width: 300px;
            height: 200px;
            position: relative;
            margin: 20px auto;
            border: 1px solid;
            overflow: hidden;
        }
        #lunbo{
            width: 9999em;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        li{
            float: left;
            width: 300px;
            height: 200px;
            text-align: center;
            line-height: 200px;
            color: brown;
            font-size: 30px;
        }
    </style>
</head>
<body>
    <div id="continer">
        <ul class="ul" id="lunbo">
            <li class="list">1</li>
            <li class="list">2</li>
            <li class="list">3</li>
            <li class="list">4</li>
            <li class="list">5</li> 
        </ul>
    </div>
</body>
<script src="./js/jquery3.0.min.js"></script>
<script>
    let selectNum = 0
    function lunboFun (selectNum, time) {
        $('#lunbo').animate({
            'left': -1 * selectNum * 300
        }, time, () => {
            selectNum++
            setTimeout(() => {
                if (selectNum > 4) {
                    selectNum = 0
                    $('ul li:last').css({
                        'position': 'absolute'
                    }, 0)
                    $('ul li:last').animate({
                        'left': -300
                    }, 0)
                    $('#lunbo').animate({
                        'left': 300
                    }, 0)
                } else if (selectNum <3) {
                    $('ul li:last').css({
                        'position': 'relative',
                        'left': 0
                    }, 0)
                }
                lunboFun(selectNum, 1000)
            }, 2000)
        });
    }
    lunboFun(selectNum, 1000)

</script>
</html>


模拟实现一个 Promise.finally?
Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  => P.resolve(callback()).then(() => value, () => value),
    reason => P.resolve(callback()).then(() => { throw reason }, () => {throw reason})
  );
};
如上在阮大神关于 finally 的写法中补充了一点。不知是否正确，欢迎探讨和学习。

callback 可能存在返回 promise，而该 promise 如果 reject，P.resolve 就会 reject，如果 P.resolve().then() 没有设置第二个回调，那么 this.then 的最终状态将是 reject 的状态，这与 es6 中所表现出来的 finally 的行为不一致。

如下是 es6 所表现的行为：
new Promise((resolve, reject) => resolve(111)).finally(Promise.reject(222)) // 此时 es6 表现的行为状态为 resolve(111)，而非 reject(222)

a.b.c.d 和 a['b']['c']['d']，哪个性能更高？
应该是 a.b.c.d 比 a['b']['c']['d'] 性能高点，后者还要考虑 [ ] 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。

ES6 代码转成 ES5 代码的实现思路是什么 ?
把 ES6 代码转成 ES5 代码的实现思路可以分成三步：

打开冰箱
把大象装进去
关上冰箱
喔，不对，原谅我开了个玩笑，嗯，有点冷……

回到正题上来，说到 ES6 代码转成 ES5 代码，我们肯定会想到 Babel。所以，我们可以参考 Babel 的实现方式。

那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：

将代码字符串解析成抽象语法树，即所谓的 AST
对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码
根据处理后的 AST 再生成代码字符串
基于此，其实我们自己就可以实现一个简单的“编译器”，用于把 ES6 代码转成 ES5。

比如，可以使用 @babel/parser 的 parse 方法，将代码字符串解析成 AST；使用 @babel/core 的 transformFromAstSync 方法，对 AST 进行处理，将其转成 ES5 并生成相应的代码字符串；过程中，可能还需要使用 @babel/traverse 来获取依赖文件等。对此感兴趣的可以看看这个。

如果有误，希望可以帮忙指出来，多谢。

随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。?
function formArray(arr: any[]) {
  const sortedArr = Array.from(new Set(arr)).sort((a, b) => a - b);

  const map = new Map();

  sortedArr.forEach((v) => {
    const key = Math.floor(v / 10);
    const group = map.get(key) || [];
    group.push(v);

    map.set(key, group);
  });

  return [...map.values()];
}

// 求连续的版本
function formArray1(arr: any[]) {
  const sortedArr = Array.from(new Set(arr)).sort((a, b) => a - b);

  return sortedArr.reduce((acc, cur) => {
    const lastArr = acc.slice().pop() || [];

    const lastVal = lastArr.slice().pop();
    if (lastVal!=null && cur-lastVal === 1) {
      lastArr.push(cur);
    } else {
      acc.push([cur]);
    }

    return acc;
  }, []);
}

function genNumArray(num: number, base = 100) {
  return Array.from({length: num}, () => Math.floor(Math.random()*base));
}

const arr = genNumArray(10, 20); //[2, 10, 3, 4, 5, 11, 10, 11, 20];
const res = formArray(arr);

console.log(`res ${JSON.stringify(res)}`);

如何解决移动端 Retina 屏 1px 像素问题 ?
1 伪元素 + transform scaleY(.5)
2 border-image
3 background-image
4 box-shadow
1. 建议使用 padding 代替 margin
我们在设计稿还原的时候，padding 和 margin 两个是常用的属性，但我们知道属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠，所以如果 margin 使用的过于频繁的时候，Box 的垂直距离可能就会发生重叠。
还有一个问题就是第一个子元素的 margin-top 值会加在父元素上的 bug（最后一个子元素的 margin-bottom 也存在类似的问题）。这里是不是有人问为什么呢？
原因就在于：

the expression collapsing margins means that adjoining margins (no non-empty content, padding or border areas or clearance separate them) of two or more boxes (which may be next to one another or nested) combine to form a single margin.

翻译过来就是:

所有毗邻的两个或多个盒元素的 margin 将会合并为一个 margin 共享。 毗邻的定义为：同级或者嵌套的盒元素，并且它们之间没有非空内容、Padding 或 Border 分隔。

至于为什么合并我个人觉得这和排队的安全距离有点类似，人与人之间的安全距离是 1m，如果安全距离不合并，那么我们在排队的时候是不是人与人的距离就变成 2m 了。当然很可能不是这个原因。
所以我们可以在首位元素使用 padding 来替代 margin。当然有的时候使用 padding 不能满足需求，这时你也可以在“非空内容”这个条件做文章。即在父元素添加一个伪元素。

所以我们在使用 margin 的时候一定要注意 collapsing margins 问题。

2. position:fixed 降级问题
不知道曾经的你是不是遇到吸顶效果，就是使用 position:fixed 这个属性。其实如果其父元素中有使用 transform，fixed 的效果会降级为 absolute。
解决方案：
既然会降级为 absolute 效果，我们该怎么解决这个问题呢？我们就改考虑什么情况下 fixed 和 absolute 的表现效果会是一样的。
即当使用 fixed 的直接父元素的高度和屏幕的高度相同时 fixed 和 absolute 的表现效果会是一样的。

如果这个直接父级内的元素存在滚动的情况，那就加上 overflow-y: auto。

3. 合理使用 px | em | rem | % 等单位
在 CSS 中有许多距离单位，比如 px | em | rem | %，还有 CSS3 中的 vh | vw 等单位。
那么我们在项目中应该如何使用呢？我们在 pc 端不需要考虑的这么复杂，所以这里我们主要讲讲这些单位在移动端中的使用。
基础单位 px
px 是我们最早接触到的单位了，不过我们在移动端自适应的要求下，使用的频率不是很高；我总结了以下使用的情况：
比较小的图案
比如需要我们画一个 r 为 5px 的圆，如果我们使用 rem 作为单位，我们很快会发现在一些机型上的图案不圆，会呈现椭圆形。这是由于 rem 转 px 会存在精度丢失问题。
所以这个时候我们就需要使用 px 配合 dpr 来实现：
// less 
/*@size 建议取双数*/
.circle(@size, @backgroundColor) {  
    width: @size;
    height: @size;
    background-color: @backgroundColor;
    [data-dpr="1"] & {
        width: @size * 0.5;
        height: @size * 0.5;
    }
    [data-dpr="3"] & {
        width: @size * 1.5;
        height: @size * 1.5;
    }
}
复制代码1px 细线问题
这个问题下面我会单独做一小节讲，在这里就不累述。
字体大小（基本都是用 rem 作为单位）
一般情况字体的大小我也会使用 rem 作为单位，因为精度丢失我认为在可以接受的范围之内。
相对单位 rem
rem 是 CSS3 新增的一个相对单位（root em），即相对 HTML 根元素的字体大小的值。
rem 应该是自适应使用的最广泛的单位了。
相对单位 em
em 也是一个相对单位，却是相对于当前对象内文本的字体大小。
line-height
一般建议在 line-height 使用 em。因为在需要调整字体大小的时候，只需修改 font-size 的值，而 line-height 已经设置成了相对行高了。
首行缩进两个字符
在存在首行缩进的需求，我也会使用这个单位。
text-indent: 2em
复制代码视口单位 vw | vh

vw: 1vw = 视口宽度的 1%
vh: 1vh = 视口高度的 1%

我们知道以 rem 单位设计的弹性布局，是需要在头部加载一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得 CSS 与 JS 耦合了在一起。
那么有没有方案解决这个耦合的问题呢？

答案就是视口单位 vw | vh。

以下就是前人给出的使用方案：
$vm_fontsize: 75;
@function rem($px) {
     @return ($px / $vm_fontsize ) * 1rem;
}
$vm_design: 750;
html {
    font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; 
    @media screen and (max-width: 320px) {
        font-size: 64px;
    }
    @media screen and (min-width: 540px) {
        font-size: 108px;
    }
}
// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小
body {
    max-width: 540px;
    min-width: 320px;
}
复制代码4. 合理使用变量
一般设计稿中的某一类的文字（元素）都是用相同的字体大小、颜色、行高等样式属性，所以这些值我们不必每次都重复写，因为当 UI 更新设计方案，你需要改的地方就很多了。这些重复使用的值我们完全可以存放在变量里面。
Sass 和 Less 稍微有点区别：
// sass
$direction: left;
// less
@direction: left;
复制代码当然 CSS 原生也是存在变量的，使用规则如下：

变量定义的语法是： --*；  //  为变量名称。
变量使用的语法是：var()；


无论是变量的定义和使用只能在声明块 {} 里面
CSS 变量字符限制为： [0-9]、[a-zA-Z]、_、-、中文和韩文等。

:root {
    --blue_color: #3388ff;
    --main_bgcolor: #fafafa;
    --font_size_12: 12px;
    --font_size_14: 14px;
    --color: 20px;
}
.div1{
    background-color: var(--main_bgcolor);
    font-size: var(--font_size_12);
}
复制代码5. 使用 Mixin 归类重复样式
和重复变量一样，重复的样式也可以归类。我觉得优秀的代码其中有一条肯定是代码的复用性强。
之前我们写 CSS 的时候，也会将一些重复使用的代码放在一个 class 中，这样的确达到了一定的复用性，不过最后的效果可能就是在一个元素里面放了很多 class，如下图：

这样下一个接手得人难免会有点迷糊，而且这样会造成样式越来越难修改。
这个时候，mixin( 可以理解成 class 中的 class )就能发挥它的作用了。
这是一个描述性文字的样式：
.font-description {
    .font-des-style(24px,#fff,1.5em);
    .line-camp(2);
}

// less
/* 多行显示 */
.line-camp( @clamp:2 ) {
    text-overflow: -o-ellipsis-lastline;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: @clamp;
    -webkit-box-orient: vertical; 
}

.font-des-style( @fontSize, @color, @lineHeight, @textAlign:left ) {
    font-size: @fontSize;
    color: @color;
    line-height: @lineHeight;
    text-align: @textAlign;
}
复制代码这只是一个简单的例子，我们可以把可复用的样式放在 mixin 中，这样接手项目的人只需要熟悉你写的 mixin.less 就可以开始迭代需求了。
6. 1px 方案
做过移动端需求的前端肯定是避免不了处理 1px 细线问题，这个问题的原因就是 UI 对页面美观度的要求越来越高（不要和我说这是 retina 屏的问题）。
据小生所知好像没有什么兼容性特别好的方案，这里我只是提供两种种相对较好的方案。
使用伪类 + transform
.border_bottom { 
    overflow: hidden; 
    position: relative; 
    border: none!important; 
}
.border_bottom:after { 
    content: "";
    display: block;
    position: absolute; 
    left: 0; 
    bottom: 0; 
    width: 100%; 
    height: 1px; 
    background-color: #d4d6d7; 
    -webkit-transform-origin: 0 0;  
    transform-origin: 0 0; 
    -webkit-transform: scaleY(0.5);
    transform: scaleY(0.5);
}
复制代码当然这个方案在一些版本较低的机型也是会出现粗细不均、细线消失断裂的兼容性问题。不过现在已经 2019 年了，版本较低的机型也淘汰的差不多了。
使用 box-shadow 模拟
.border_bottom {
  box-shadow: inset 0px -1px 1px -1px #d4d6d7;
}
复制代码这个方案基本可以满足所有场景，不过有个缺点也就是颜色会变浅。
多谢 D文斌 分享的另一种方案：
这种方案对 dpr 做了不同的处理，可谓更加精细。
.min-device-pixel-ratio(@scale2, @scale3) {
  @media screen and (min-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2) {
    transform: @scale2;
  }
  @media screen and (min-device-pixel-ratio: 3), (-webkit-min-device-pixel-ratio: 3) {
    transform: @scale3;
  }
}

.border-1px(@color: #DDD, @radius: 2PX, @style: solid) {
  &::before {
    content: "";
    pointer-events: none;
    display: block;
    position: absolute;
    left: 0;
    top: 0;
    transform-origin: 0 0;
    border: 1PX @style @color;
    border-radius: @radius;
    box-sizing: border-box;
    width: 100%;
    height: 100%;
    @media screen and (min-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2) {
      width: 200%;
      height: 200%;
      border-radius: @radius * 2;
      transform: scale(.5);
    }
    @media screen and (min-device-pixel-ratio: 3), (-webkit-min-device-pixel-ratio: 3) {
      width: 300%;
      height: 300%;
      border-radius: @radius * 3;
      transform: scale(.33);
    }
  }
}

.border-top-1px(@color: #DDD, @style: solid) {
  &::before {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    border-top: 1Px @style @color;
    transform-origin: 0 0;
    .min-device-pixel-ratio(scaleY(.5), scaleY(.33));
  }
}
复制代码7. 从 html 元素继承 box-sizing
在大多数情况下我们在设置元素的 border 和 padding 并不希望改变元素的 width,height 值，这个时候我们就可以为该元素设置 box-sizing:border-box;。
我不希望每次都重写一遍，而是希望他是继承而来的，那么我们可以使用如下代码：
html {
  box-sizing: border-box;
}
*, *:before, *:after {
  box-sizing: inherit;
}
复制代码这样的好处在于他不会覆盖其他组件的 box-sizing 值，又无需为每一个元素重复设置 box-sizing: border-box;。
8. 内联首屏关键 CSS
性能优化中有一个重要的指标 —— 首次有效绘制（FMP），即指页面的首要内容（primary content）出现在屏幕上的时间。这一指标影响用户看到页面前所需等待的时间，而 内联首屏关键 CSS（即 Critical CSS，可以称之为首屏关键 CSS） 能给用户一个更好的心理预期。
如图：

我们知道内联 CSS 能够使浏览器开始页面渲染的时间提前，即在 HTML 下载完成之后就能渲染了。

既然是内联关键 CSS，也就说明我们只会将少部分的 CSS 代码直接写入 HTML 中。至于内联哪些 CSS 你可以使用 Critical。

9. 文字超出省略、文字两端对齐
需求中我们也经常遇到这样的需求，这里直接提供方案。
超出省略
.line-camp( @clamp:2 ) {
    text-overflow: -o-ellipsis-lastline;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: @clamp;
    -webkit-box-orient: vertical; 
}
复制代码所遇到的问题：

-webkit-box-orient: vertical 在使用 webpack 打包的时候这段代码会被删除掉，原因是  optimize-css-assets-webpack-plugin 这个插件的问题。

解决方案：
可以使用如下的写法：
.line-camp( @clamp:2 ) {
    text-overflow: -o-ellipsis-lastline;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: @clamp;
    /*! autoprefixer: off */
    -webkit-box-orient: vertical;
    /* autoprefixer: on */
}
复制代码
两端对齐
// html
<div>姓名</div>
<div>手机号码</div>
<div>账号</div>
<div>密码</div>

// css
div {
    margin: 10px 0; 
    width: 100px;
    border: 1px solid red;
    text-align: justify;
    text-align-last:justify
}
div:after{
    content: '';
    display: inline-block;
    width: 100%;
}
链接：https://juejin.im/post/5cb45a06f265da03474df54e

如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC' 变成 'aBc' 。?
'AbcDefGh'.replace(/[a-zA-Z]/g,function(a){ return /[a-z]/.test(a)?a.toUpperCase():a.toLowerCase(); });

[].map.call(str, function(item){ 
return /[a-z]/.test(item) ? item.toUpperCase() : item.toLowerCase();
}).join('');

介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面?
关于webpack的热更新原理，面试官比较想听到的是工作流程和关键点，非“流水账”式的源码分析。我认为可以这样的介绍：

首先，介绍webpack-dev-server:
webpack-dev-server 主要包含了三个部分：
1.webpack: 负责编译代码
2.webpack-dev-middleware: 主要负责构建内存文件系统，把webpack的 OutputFileSystem 替换成 InMemoryFileSystem。同时作为Express的中间件拦截请求，从内存文件系统中把结果拿出来。
3.express：负责搭建请求路由服务。

其次，介绍工作流程:
1.启动dev-server，webpack开始构建，在编译期间会向 entry 文件注入热更新代码；
2.Client 首次打开后，Server 和 Client 基于Socket建立通讯渠道；
3.修改文件，Server 端监听文件发送变动，webpack开始编译，直到编译完成会触发"Done"事件；
4.Server通过socket 发送消息告知 Client；
5.Client根据Server的消息（hash值和state状态），通过ajax请求获取 Server 的manifest描述文件；
6.Client对比当前 modules tree ，再次发请求到 Server 端获取新的JS模块；
7.Client获取到新的JS模块后，会更新 modules tree并替换掉现有的模块；
8.最后调用 module.hot.accept() 完成热更新；

实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。 ?
// 因为 T 的 length 是一定的，所以在循环S的的时候 ，循环当前项 i 后面至少还有 T.length 个元素
const find = (S, T) => {
  if (S.length < T.length) return -1;
  for (let i = 0; i < S.length - T.length ; i++) {
      if (S.substr(i, T.length) === T) return i ;
  };
  return -1;
};

为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因?
for循环本来就是最原始的循环方案 foreach是基于它封装的
for 循环没有任何额外的函数调用栈和上下文；

forEach函数签名实际上是
array.forEach(function(currentValue, index, arr), thisValue)
它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；

介绍下 BFC、IFC、GFC 和 FFC?
BFC（Block formatting contexts）：块级格式上下文
页面上的一个隔离的渲染区域，那么他是如何产生的呢？可以触发BFC的元素有float、position、overflow、display：table-cell/ inline-block/table-caption ；BFC有什么作用呢？比如说实现多栏布局’

IFC（Inline formatting contexts）：内联格式上下文
IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同
IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。
那么IFC一般有什么用呢？
水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。
垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。

GFC（GrideLayout formatting contexts）：网格布局格式化上下文
当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。

FFC（Flex formatting contexts）:自适应格式上下文
display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。

使用 JavaScript Proxy 实现简单的数据绑定 ?
<body>
  hello,world
  <input type="text" id="model">
  <p id="word"></p>
</body>
<script>
  const model = document.getElementById("model")
  const word = document.getElementById("word")
  var obj= {};

  const newObj = new Proxy(obj, {
      get: function(target, key, receiver) {
        console.log(`getting ${key}!`);
        return Reflect.get(target, key, receiver);
      },
      set: function(target, key, value, receiver) {
        console.log('setting',target, key, value, receiver);
        if (key === "text") {
          model.value = value;
          word.innerHTML = value;
        }
        return Reflect.set(target, key, value, receiver);
      }
    });

  model.addEventListener("keyup",function(e){
    newObj.text = e.target.value
  })
</script>

数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少?
JavaScript 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 key）来使用。所以无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。
js 中数组元素的存储方式并不是连续的，而是哈希映射关系。哈希映射关系，可以通过键名 key，直接计算出值存储的位置，所以查找起来很快。推荐一下这篇文章：深究 JavaScript 数组 https://juejin.im/entry/59ae664d518825244d207196

旋转数组算法题?
因为步数有可能大于数组长度，所以要先取余

function rotate(arr, k) {
  const len = arr.length
  const step = k % len
  return arr.slice(-step).concat(arr.slice(0, len - step))
}
// rotate([1, 2, 3, 4, 5, 6], 7) => [6, 1, 2, 3, 4, 5]

问题转化为：数组的末尾k个元素移动到数组前面
末尾元素：arr.splice(-k%arr.length)的返回值
剩余元素：arr

const moveArr = (arr,k)=>arr.splice(-k%arr.length).concat(arr)
test:
moveArr([1,2,3,4,5,6,7],0) => [1,2,3,4,5,6,7]
moveArr([1,2,3,4,5,6,7],5) => [3,4 5,6,7,1,2]
moveArr([1,2,3,4,5,6,7],8) => [7,1,2,3,4,5,6]

输出以下代码运行结果?
这题考察的是对象的键名的转换。

对象的键名只能是字符串和 Symbol 类型。
其他类型的键名会被转换成字符串类型。
对象转字符串默认会调用 toString 方法。
// example 1
var a={}, b='123', c=123;
a[b]='b';

// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉。
a[c]='c';  

// 输出 c
console.log(a[b]);
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');  

// b 是 Symbol 类型，不需要转换。
a[b]='b';

// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。
a[c]='c';

// 输出 b
console.log(a[b]);
// example 3
var a={}, b={key:'123'}, c={key:'456'};  

// b 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。
a[b]='b';

// c 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。
a[c]='c';  

// 输出 c
console.log(a[b]);

Vue 的父组件和子组件生命周期钩子执行顺序是什么?
加载渲染过程
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
子组件更新过程
父beforeUpdate->子beforeUpdate->子updated->父updated
父组件更新过程
父beforeUpdate->父updated
销毁过程
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

input 搜索如何防抖，如何处理中文输入?
防抖就不说了，主要是这里提到的中文输入问题，其实看过elementui框架源码的童鞋都应该知道，elementui是通过compositionstart & compositionend做的中文输入处理：
相关代码：
<input
ref="input"
@compositionstart="handleComposition"
@compositionupdate="handleComposition"
@compositionend="handleComposition"
>
这3个方法是原生的方法，这里简单介绍下，官方定义如下compositionstart 事件触发于一段文字的输入之前（类似于 keydown 事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）
简单来说就是切换中文输入法时在打拼音时(此时input内还没有填入真正的内容)，会首先触发compositionstart，然后每打一个拼音字母，触发compositionupdate，最后将输入好的中文填入input中时触发compositionend。触发compositionstart时，文本框会填入 “虚拟文本”（待确认文本），同时触发input事件；在触发compositionend时，就是填入实际内容后（已确认文本）,所以这里如果不想触发input事件的话就得设置一个bool变量来控制。
image
根据上图可以看到

输入到input框触发input事件
失去焦点后内容有改变触发change事件
识别到你开始使用中文输入法触发**compositionstart 事件
未输入结束但还在输入中触发compositionupdate **事件
输入完成（也就是我们回车或者选择了对应的文字插入到输入框的时刻）触发compositionend事件。

那么问题来了 使用这几个事件能做什么？
因为input组件常常跟form表单一起出现，需要做表单验证
image
为了解决中文输入法输入内容时还没将中文插入到输入框就验证的问题

我们希望中文输入完成以后才验证

介绍下 Promise.all 使用、原理实现及错误处理 ？
const p = Promise.all([p1, p2, p3]);
Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）

一、Promise概念
Promise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一。Promise.all()接受一个由promise任务组成的数组，可以同时处理多个promise任务，当所有的任务都执行完成时，Promise.all()返回resolve，但当有一个失败(reject)，则返回失败的信息，即使其他promise执行成功，也会返回失败。和后台的事务类似。和rxjs中的forkJoin方法类似，合并多个 Observable 对象 ，等到所有的 Observable 都完成后，才一次性返回值。

二、Promise.all如何使用
对于 Promise.all(arr) 来说，在参数数组中所有元素都变为决定态后，然后才返回新的 promise。

// 以下 demo，请求两个 url，当两个异步请求返还结果后，再请求第三个 url
const p1 = request(`http://some.url.1`)
const p2 = request(`http://some.url.2`)
Promise.all([p1, p2])
  .then((datas) => { // 此处 datas 为调用 p1, p2 后的结果的数组
    return request(`http://some.url.3?a=${datas[0]}&b=${datas[1]}`)
  })
  .then((data) => {
    console.log(msg)
  })

三、Promise.all原理实现
function promiseAll(promises){
     return new Promise(function(resolve,reject){
            if(!Array.isArray(promises)){
             return reject(new TypeError("argument must be anarray"))
           }
    var countNum=0;
    var promiseNum=promises.length;
    var resolvedvalue=new Array(promiseNum);
    for(var i=0;i<promiseNum;i++){
      (function(i){
         Promise.resolve(promises[i]).then(function(value){
            countNum++;
           resolvedvalue[i]=value;
          if(countNum===promiseNum){
              return resolve(resolvedvalue)
          }
       },function(reason){
        return reject(reason)
      )
     })(i)
    }
})
}
var p1=Promise.resolve(1),
p2=Promise.resolve(2),
p3=Promise.resolve(3);
promiseAll([p1,p2,p3]).then(function(value){
console.log(value)
})
四、Promise.all错误处理
有时候我们使用Promise.all()执行很多个网络请求，可能有一个请求出错，但我们并不希望其他的网络请求也返回reject，要错都错，这样显然是不合理的。如何做才能做到promise.all中即使一个promise程序reject，promise.all依然能把其他数据正确返回呢?

1、全部改为串行调用（失去了node 并发优势）
2、当promise捕获到error 的时候，代码吃掉这个异常，返回resolve，约定特殊格式表示这个调用成功了
var p1 =new Promise(function(resolve,reject){
    setTimeout(function(){
        resolve(1);
    },0)
});
var p2 = new Promise(function(resolve,reject){
        setTimeout(function(){
            resolve(2);
        },200)
 });
 var p3 = new Promise(function(resolve,reject){
        setTimeout(function(){
            try{
            console.log(XX.BBB);
            }
            catch(exp){
                resolve("error");
            }
        },100)
});
Promise.all([p1, p2, p3]).then(function (results) {
    console.log("success")
     console.log(results);
}).catch(function(r){
    console.log("err");
    console.log(r);
});

打印出 1 - 10000 之间的所有对称数 例如 121、1331 等？
[...Array(10000).keys()].filter((x) => { 
  return x.toString().length > 1 && x === Number(x.toString().split('').reverse().join('')) 
})

let result=[]
for(let i=1;i<10;i++){
    result.push(i)
    result.push(i*11)
    for(let j=0;j<10;j++){
        result.push(i*101+j*10)
        result.push(i*1001+j*110)
    }
}//没必要去遍历10000个数

var、let 和 const 区别的实现原理是什么?
变量生命周期：声明（作用域注册一个变量）、初始化（分配内存，初始化为undefined）、赋值

var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来
function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高
let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行
const、class都是同let一样的道理
比如解析如下代码步骤：

{
// 没用的第一行
// 没用的第二行
console.log(a) // 如果此时访问a报错 a is not defined
let a = 1
}
步骤：

发现作用域有let a，先注册个a，仅仅注册
没用的第一行
没用的第二行
a is not defined，暂时性死区的表现
假设前面那行不报错，a初始化为undefined
a赋值为1
对比于var，let、const只是解耦了声明和初始化的过程，var是在任何语句执行前都已经完成了声明和初始化，let、const仅仅是在任何语句执行前只完成了声明

算法题「移动零」，给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。?
示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:
必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。
新增：解决了有连续的0无法实现功能的问题。

function zeroMove(array) {
    let len = array.length;
    let j = 0;
    for(let i=0;i<len-j;i++){
        if(array[i]===0){
            array.push(0);
            array.splice(i,1);
            i --;
            j ++;
        }
    }
    return array;
}

  const moveZore = (arr) => {
      let n = 0
      arr.forEach((item, index) => {
          if (item === 0){
              arr.splice(index, 1)
              n++;
          }
      })
      arr.push(...(new Array(n)).fill(0))
      return arr;
  }

请实现一个 add 函数，满足以下功能。?
  function add() {
  let args = [].slice.call(arguments);
  let fn = function(){
   let fn_args = [].slice.call(arguments)
   return add.apply(null,args.concat(fn_args))
 }
fn.toString = function(){
  return args.reduce((a,b)=>a+b)
}
return fn
}
https://github.com/yygmind/blog/issues/37
https://github.com/yygmind/blog/issues/36#%E6%80%9D%E8%80%83%E9%A2%98

react-router 里的 <Link> 标签和 <a> 标签有什么区别?
先看Link点击事件handleClick部分源码

      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore everything but left clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;


          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
Link做了3件事情：

有onclick那就执行onclick
click的时候阻止a标签默认事件（这样子点击<a href="/abc">123</a>就不会跳转和刷新页面）
再取得跳转href（即是to），用history（前端路由两种方式之一，history & hash）跳转，此时只是链接变了，并没有刷新页面

算法题之「两数之和」?
给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。

你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

示例：

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

var twoSum = function(nums, target) {
  const map = {}
  for (let i = 0; i < nums.length; i++) {
    const n = nums[i]
    if (target - n in map) {
      return [map[target - n], i]
    } else {
      map[n] = i
    }
  }
}
// 暴力破解法
function findTowOfSum(nums, target) {
  let i, j;

  for (i = 0; i < nums.length; i++) {
    for (j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
  return null;
}

在输入框中如何判断输入的是一个正确的网址?
what is a URL from MDN
补个资料。
思路应该是对 URL的组成部分 分别进行校验

protocol
domain name
port
path （不用校验）
params
anchor （不用校验）
let url = 'https://www.baidu.com';
function searchUrl(url) {
    try {
        if (new URL(url) && (new URL(url).protocol === "http:" || new URL(url).protocol === "https:") && url.match(new RegExp(new URL(url).protocol + "//")).index === 0) return true
    } catch (err) {
        console.log("不是一个正确的网址");
    }
};
console.log(searchUrl(url))

实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度?
以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：

// 原始 list 如下
let list =[
    {id:1,name:'部门A',parentId:0},
    {id:2,name:'部门B',parentId:0},
    {id:3,name:'部门C',parentId:1},
    {id:4,name:'部门D',parentId:1},
    {id:5,name:'部门E',parentId:2},
    {id:6,name:'部门F',parentId:3},
    {id:7,name:'部门G',parentId:2},
    {id:8,name:'部门H',parentId:4}
];
const result = convert(list, ...);

// 转换后的结果如下
let result = [
    {
      id: 1,
      name: '部门A',
      parentId: 0,
      children: [
        {
          id: 3,
          name: '部门C',
          parentId: 1,
          children: [
            {
              id: 6,
              name: '部门F',
              parentId: 3
            }, {
              id: 16,
              name: '部门L',
              parentId: 3
            }
          ]
        },
        {
          id: 4,
          name: '部门D',
          parentId: 1,
          children: [
            {
              id: 8,
              name: '部门H',
              parentId: 4
            }
          ]
        }
      ]
    },
  ···
];

function convert(list) {
	const res = []
	const map = list.reduce((res, v) => (res[v.id] = v, res), {})
	for (const item of list) {
		if (item.parentId === 0) {
			res.push(item)
			continue
		}
		if (item.parentId in map) {
			const parent = map[item.parentId]
			parent.children = parent.children || []
			parent.children.push(item)
		}
	}
	return res
}

执行语句for(i=1;i++<10; );后变量i的值是?
for (var i = 1; i++ < 10;) {
    console.log(i)
}
console.log(i) //11

实现模糊搜索结果的关键词高亮显示?
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>auto complete</title>
  <style>
    bdi {
      color: rgb(0, 136, 255);
    }

    li {
      list-style: none;
    }
  </style>
</head>
<body>
  <input class="inp" type="text">
  <section>
    <ul class="container"></ul>
  </section>
</body>
<script>

  function debounce(fn, timeout = 300) {
    let t;
    return (...args) => {
      if (t) {
        clearTimeout(t);
      }
      t = setTimeout(() => {
        fn.apply(fn, args);
      }, timeout);
    }
  }

  function memorize(fn) {
    const cache = new Map();
    return (name) => {
      if (!name) {
        container.innerHTML = '';
        return;
      }
      if (cache.get(name)) {
        container.innerHTML = cache.get(name);
        return;
      }
      const res = fn.call(fn, name).join('');
      cache.set(name, res);
      container.innerHTML = res;
    }
  }

  function handleInput(value) {
    const reg = new RegExp(`\(${value}\)`);
    const search = data.reduce((res, cur) => {
      if (reg.test(cur)) {
        const match = RegExp.$1;
        res.push(`<li>${cur.replace(match, '<bdi>$&</bdi>')}</li>`);
      }
      return res;
    }, []);
    return search;
  }
  
  const data = ["上海野生动物园", "上饶野生动物园", "北京巷子", "上海中心", "上海黄埔江", "迪士尼上海", "陆家嘴上海中心"]
  const container = document.querySelector('.container');
  const memorizeInput = memorize(handleInput);
  document.querySelector('.inp').addEventListener('input', debounce(e => {
    memorizeInput(e.target.value);
  }))
</script>
</html>

vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？
说一下我个人理解，先说结论，可以使用

事件代理作用主要是 2 个

将事件处理程序代理到父节点，减少内存占用率
动态生成子节点时能自动绑定事件处理程序到父节点
这里我生成了十万个 span 节点，通过 performance monitor 来监控内存占用率和事件监听器的数量，对比以下 3 种情况

不使用事件代理，每个 span 节点绑定一个 click 事件，并指向同一个事件处理程序
  <div>
      <span 
        v-for="(item,index) of 100000" 
        :key="index" 
        @click="handleClick">
        {{item}}
      </span>
    </div>
不使用事件代理，每个 span 节点绑定一个 click 事件，并指向不同的事件处理程序
  <div>
      <span 
        v-for="(item,index) of 100000" 
        :key="index" 
        @click="function () {}">
        {{item}}
      </span>
    </div>
使用事件代理
<div  @click="handleClick">
      <span 
        v-for="(item,index) of 100000"  
        :key="index">
        {{item}}
      </span>
    </div>
可以看到使用事件代理无论是监听器数量和内存占用率都比前两者要少

同时对比 3 个图中监听器的数量以及我以往阅读 vue 源码的过程中，并没有发现 vue 会自动做事件代理，但是一般给 v-for 绑定事件时，都会让节点指向同一个事件处理程序（第二种情况可以运行，但是 eslint 会警告），一定程度上比每生成一个节点都绑定一个不同的事件处理程序性能好，但是监听器的数量仍不会变，所以使用事件代理会更好一点

模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况 ?
export function deepCopy (obj, cache = []) {
  // just return if obj is immutable value
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // if obj is hit, it is in circular structure
  const hit = find(cache, c => c.original === obj)
  if (hit) {
    return hit.copy
  }

  const copy = Array.isArray(obj) ? [] : {}
  // put the copy into cache at first
  // because we want to refer it in recursive deepCopy
  cache.push({
    original: obj,
    copy
  })

  Object.keys(obj).forEach(key => {
    copy[key] = deepCopy(obj[key], cache)
  })

  return copy
}

写出如下代码的打印结果?
function changeObjProperty(o) {
o.siteUrl = "http://www.baidu.com"
o = new Object() // 形参 o 的指向发生改变，指向堆内存中一个新的对象
o.siteUrl = "http://www.google.com"
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl); //"http://www.baidu.com"

用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。?
function fun(num){
    let num1 = num / 10;
    let num2 = num % 10;
    if(num1<1){
        return num;
    }else{
        num1 = Math.floor(num1)
        return `${num2}${fun(num1)}`
    }
}
var a = fun(12345)
console.log(a)
console.log(typeof a)

请写出如下代码的打印结果?
输出顺序是 4 2 1 .

function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行

Foo.prototype.a = function() {
    console.log(3)
}
// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3

Foo.a = function() {
    console.log(4)
}
// 现在在 Foo 上挂载了直接方法 a ，输出值为 4

Foo.a();
// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以
// # 输出 4

let obj = new Foo();
/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：
1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。
2. 在新对象上挂载直接方法 a ，输出值为 2。
*/

obj.a();
// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，
// # 输出 2

Foo.a();
// 构建方法里已经替换了全局 Foo 上的 a 方法，所以
// # 输出 1


修改以下 print 函数，使之输出 0 到 99，或者 99 到 0?
function print(n){
  setTimeout(() => {
    console.log(n);
  }, 1, Math.floor(Math.random() * 1000));
}
for(var i = 0; i < 100; i++){
  print(i);
}


function print(n){
  setTimeout(console.log(n), Math.floor(Math.random() * 1000));
}

for(var i = 0; i < 100; i++) {
  print(i);
}
99到0，就是 99 - n

function print(n){
  setTimeout(console.log(99 - n), Math.floor(Math.random() * 1000));
}

for(var i = 0; i < 100; i++) {
  print(i);
}
两种解法：

利用settimeout 接受多个参数的方向，将Math.floor(Math.random() * 1000)作为第三个参数，第二参数可以设置为任意值。
function print(n){
setTimeout(() => {
console.log(n);
}, 1, Math.floor(Math.random() * 1000));
}
for(var i = 0; i < 100; i++){
print(i);
}
2.可以利用settimeout 第一个参数可以是function是立即执行或者一个执行函数。

模拟 localStorage 时如何实现过期时间功能?
用 cookie 模拟 localStorage
参考 https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/LocalStorage

if (!window.localStorage) {
  window.localStorage = {
    getItem: function (sKey) {
      if (!sKey || !this.hasOwnProperty(sKey)) { return null; }
      return unescape(document.cookie.replace(new RegExp("(?:^|.*;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"), "$1"));
    },
    key: function (nKeyId) {
      return unescape(document.cookie.replace(/\s*\=(?:.(?!;))*$/, "").split(/\s*\=(?:[^;](?!;))*[^;]?;\s*/)[nKeyId]);
    },
    setItem: function (sKey, sValue) {
      if(!sKey) { return; }
      document.cookie = escape(sKey) + "=" + escape(sValue) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
      this.length = document.cookie.match(/\=/g).length;
    },
    length: 0,
    removeItem: function (sKey) {
      if (!sKey || !this.hasOwnProperty(sKey)) { return; }
      document.cookie = escape(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
      this.length--;
    },
    hasOwnProperty: function (sKey) {
      return (new RegExp("(?:^|;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
    }
  };
  window.localStorage.length = (document.cookie.match(/\=/g) || window.localStorage).length;
}
扩展 localStorage 支持 expires
(function () {
  var getItem = localStorage.getItem.bind(localStorage)
  var setItem = localStorage.setItem.bind(localStorage)
  var removeItem = localStorage.removeItem.bind(localStorage)
  localStorage.getItem = function (keyName) {
    var expires = getItem(keyName + '_expires')
    if (expires && new Date() > new Date(Number(expires))) {
      removeItem(keyName)
      removeItem(keyName + '_expires')
    }
    return getItem(keyName)
  }
  localStorage.setItem = function (keyName, keyValue, expires) {
    if (typeof expires !== 'undefined') {
      var expiresDate = new Date(expires).valueOf()
      setItem(keyName + '_expires', expiresDate)
    }
    return setItem(keyName, keyValue)
  }
})()
使用
localStorage.setItem('key', 'value', new Date() + 10000) // 10 秒钟后过期
localStorage.getItem('key')
??存储的时候加个存储时间戳和有效期时长就好了啊。取的时候判断一下不就行了

不用加减乘除运算符，求整数的7倍?
function fn(x){
  let arr = Array(x)
  let resultArr = [...arr,...arr,...arr,...arr,...arr,...arr,...arr]
  return resultArr.length
}

url有三种情况

https://www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=&local_province_id=33
https://www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=800&local_province_id=33
https://www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=800,700&local_province_id=33
匹配elective后的数字输出（写出你认为的最优解法）:

[] || ['800'] || ['800','700']?

new URLSearchParams('https://www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=800,700&local_province_id=33').get('elective')


考虑到性能问题，如何快速从一个巨大的数组中随机获取部分元素?
/* 洗牌算法：
    1.生成一个0 - arr.length 的随机数
    2.交换该随机数位置元素和数组的最后一个元素，并把该随机位置的元素放入结果数组
    3.生成一个0 - arr.length - 1 的随机数
    4.交换该随机数位置元素和数组的倒数第二个元素，并把该随机位置的元素放入结果数组
    依次类推，直至取完所需的10k个元素
*/

function shuffle(arr, size) {
    let result = []
    for (let i = 0; i < size; i++) {
        const randomIndex = Math.floor(Math.random() * (arr.length - i))
        const item = arr[randomIndex]
        result.push(item)
        arr[randomIndex] = arr[arr.length - 1 - i]
        arr[arr.length - 1 - i] = item
    }
    return result
}

分别写出如下代码的返回值?
String('11') == new String('11');
String('11') === new String('11');

var str1 = String('11')
var str2 = new String('11')
str1 == str2 // true
str1 === str2 // false
typeof str1  // "string"
typeof str2 // "object"
总结：

==时做了隐式转换，调用了toString
2者类型不一样，一个是string，一个是object

var str = “32px”;
var str1 = str.slice(-2);
alert(str);
alert(str1);
依次输出”32px” “px”     解析：slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。
arr.slice(start, end);复制代码
-2表示倒数计算的第二个位置，-1表示倒数计算的第一个位置。

请写出如下代码的打印结果?
var name = 'Tom';
(function() {
    console.info('name', name);
    console.info('typeof name', typeof name);
    if (typeof name == 'undefined') {
        var name = 'Jack';
        console.log('Goodbye ' + name);
    } else {
        console.log('Hello ' + name);
    }
})();
name undefined
typeof name undefined
Goodbye Jack
var 声明的变量没有块作用域，变量会提升到最近的 function 作用域的上层，但此时只是声明了变量，并没有赋值，到实际运行了赋值语句之后才有值，在之前值为 undefined

编程题，请写一个函数，完成以下功能?
输入'1,2,3,5,7,8,10'
输出'1~3,5,7~8,10'//这道题的意思是：如果连续数字的话，就取连续的第一个数和最后一个数，中间用~隔开。如果不连续就用，隔开。
const nums1 = [1, 2, 3, 5, 7, 8, 10];
function simplifyStr(num) {
  var result = [];
  var temp = num[0]
  num.forEach((value, index) => {
    if (value + 1 !== num[index + 1]) {
      if (temp !== value) {
        result.push(`${temp}~${value}`)
      } else {
        result.push(`${value}`)
      }
      temp = num[index + 1]
    }
  })
  return result;
}
console.log(simplifyStr(nums1).join(','))

if与立即执行函数（IIFE）里面的变量提升?
说明IE11之后（至多在firefox55，chorme60之后），if 里面的 var 和 function的声明方式，都会存在变量提升，但是并不赋值
f = function() {return true;}; 
g = function() {return false;}; 
(function() { 
   if (g() && [] == ![]) { 
      f = function f() {return false;};  // 还是外部的 f
      function g() {return true;} // 变量提升，但是不赋值，并且覆盖外部 g  这里的g提升到了内部函数作用域  但是并不赋值 导致g()执行报错  VM143:4 Uncaught TypeError: g is not a function
   } 
})(); 
alert(f()); // IE11以前返回false

编程题，写个程序把 entry 转换成如下对象?
var entry = {
  'a.b.c.dd': 'abcdd',
  'a.d.xx': 'adxx',
  'a.e': 'ae'
}

// 要求转换成如下对象
var output = {
  a: {
   b: {
     c: {
       dd: 'abcdd'
     }
   },
   d: {
     xx: 'adxx'
   },
   e: 'ae'
  }
}
实现思路：
对象entry的key中含有的.就是一个对象嵌套，所以可以用split()函数将其划分为一个array，所以array的length - 1下标所对应的元素就是entry的一个key的具体值。
利用对象为地址引用原理，进行增加元素。
采用reduce函数，将每一次的引用返回。
const entry = {
  'a.b.c.dd': 'abcdd',
  'a.d.xx': 'adxx',
  'a.e': 'ae',
};
const changObjStructureOfNormal = output => {
  const keys = Object.keys(output);
  const resObj = {};
  for (const key of keys) {
    const everyKey = key.split('.');
    everyKey.reduce((pre, next, index, array) => {
      if (index === array.length - 1) {
        pre[next] = output[key];
        return;
      }
      pre[next] = pre[next] || {};
      return pre[next];
    }, resObj);
  }
  return resObj;
};
changObjStructureOfNormal(entry);

找出字符串中连续出现最多的字符和个数 ?
'abcaakjbb' => {'a':2,'b':2}
'abbkejsbcccwqaa' => {'c':3}
注意：题目说的是连续出现，注意连续二字

const arr = str.match(/(\w)\1*/g);
const maxLen = Math.max(...arr.map(s => s.length));
const result = arr.reduce((pre, curr) => {
  if (curr.length === maxLen) {
    pre[curr[0]] = curr.length;
  }
  return pre;
}, {});

console.log(result);

数组去重
function quchong(arr){
  var obj = {};
  return arr.filter(item=>{
    return obj.hasOwnProperty(typeof item+item)?false:(obj[typeof item+item]=true);
  })
}

输出以下代码运行结果？
1 + "1"
加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来

所以值为：“11”

2 * "2"
乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值

[1, 2] + [2, 1]
Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法。

所以两个数组对象的toString方法相加，值为："1,22,1"

"a" + + "b"
后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。

所以值为："aNaN"

介绍下 http1.0、1.1、2.0 协议的区别？
http/1 :

默认不支持长连接，需要设置keep-alive参数指定
强缓存expired、协商缓存last-modified\if-modified-since 有一定的缺陷
http 1.1 :

默认长连接(keep-alive)，http请求可以复用Tcp连接，但是同一时间只能对应一个http请求(http请求在一个Tcp中是串行的)
增加了强缓存cache-control、协商缓存etag\if-none-match 是对http/1 缓存的优化
http/2 :

多路复用，一个Tcp中多个http请求是并行的 (雪碧图、多域名散列等优化手段http/2中将变得多余)
二进制格式编码传输
header压缩
服务端推送

vue 渲染大量数据时应该怎么优化？
总结了一下
1.添加加载动画，优化用户体验
2.利用服务器渲染SSR，在服务端渲染组件
3.避免浏览器处理大量的dom，比如懒加载，异步渲染组件，使用分页
4.对于固定的非响应式的数据，使用Object.freeze冻结

vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？
首页白屏的原因：
单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的js文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏

解决办法：

优化 webpack 减少模块打包体积，code-split 按需加载
服务端渲染，在服务端事先拼装好首页所需的 html
首页加 loading 或 骨架屏 （仅仅是优化体验）
1.使用首屏SSR + 跳转SPA方式来优化
2.改单页应用为多页应用，需要修改webpack的entry
3.改成多页以后使用应该使用prefetch的就使用
4.处理加载的时间片，合理安排加载顺序，尽量不要有大面积空隙
5.CDN资源还是很重要的，最好分开，也能减少一些不必要的资源损耗
6.使用Quicklink，在网速好的时候 可以帮助你预加载页面资源
7.骨架屏这种的用户体验的东西一定要上，最好借助stream先将这部分输出给浏览器解析
8.合理使用web worker优化一些计算
9.缓存一定要使用，但是请注意合理使用
10.大概就这么多，最后可以借助一些工具进行性能评测，重点调优，例如使用performance自己实现下等
代码拆分。code split、动态import
多页面+单页面组合，不是整个网站都是同一个页面切换前端路由，酌情拆分一些其他页面作为新页面
直出ssr。使用ssr减少前端跑js的时间，逻辑放服务端处理把完整的页面返回
部分直出。使用ssr服务端压力会变大，所以可以把页面重要的部分先直出，非重要部分放前端
接入quicklink，实际上就是检查页面链接然后在浏览器空闲时间进行prefetch
接入service worker缓存，和ssr一起搭配使用更佳
体验上。增加lodaing、骨架屏
有了各种缓存，热启动是没什么问题了。最后要优化冷启动时间，使用prefetch
前端渲染上。使用raf渲染，不阻塞主线程。react里面已使用异步渲染
服务端rpc上。使用pb协议而不是文本协议
传输层使用quic协议传输。貌似没多少个团队用上～
常规操作。cdn、减少请求、雪碧图、gzip、浏览器缓存什么的就不多说了


webpack 打包 vue 速度太慢怎么办？
"打包慢"，是一个综合的因素，和vue关系不大。
1：确保下webpack，npm, node 及主要库版本要新，比如：4.x比3.x提升很多。
2：loader范围缩小到src项目文件！一些不必要的loader能关就关了吧
3：eslint代码校验其实是一个很费时间的一个步奏。
：可以把eslint的范围缩小到src,且只检查*.js 和 *.vue
：生产环境不开启lint，使用pre-commit或者husky在提交前校验
4：happypack多进程进行
如果上面优化后，时间还是不满意的话，就尝试下5,6吧。
5：动态链接库（DllPlugin），楼上已说。有点类似配置的externals。
补充一下：
缺点：将不能按需加载，会将配置的第三方库全部打包进去。
推荐：可以将使用率较高的包采用dll方案。
6：HardSourceWebpackPlugin会将模块编译后进行缓存，第一次之后速度会明显提升。
1、因webpack提供的UglifyJS插件采用单线程压缩，速度很慢。所以将此插件替换为webpack-parallel-uglify-plugin插件，此插件可以并行运行UglifyJS插件，可有效减少构建时间。

//首先下载插件 npm i -D webpack-parallel-uglify-plugin
//修改 webpack.prod.conf.js
//将引入的UglifyJS 和 作用代码注释掉 并替换成下方代码
const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin')
new ParallelUglifyPlugin({
          cacheDir: '.cache/',
          uglifyJS:{
              output: {
                  comments: false
              },
              compress: {
                  warnings: false,
                  drop_debugger: true,
                  drop_console: false
              }
          }
      }),
2、由于运行在node.js之上的webpack是单线程模型，所以webpack做事只能一件一件去做。HappyPack可以让webpack在同一时间处理多个任务，把任务分解给多个子进程去并发执行，处理完之后将结果发给主进程

//首先下载插件  npm install --save-dev happypack
//修改 webpack.base.conf.js
const HappyPack = require('happypack')
const os = require('os')
let happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });
//加入此插件
plugins:[
      new HappyPack({
          id:'babel',
          loaders:['babel-loader?cacheDirectory=true'],
          threadPool:happyThreadPool
      })
  ],
//将js loader作用代码替换
// loader: 'babel-loader'    替换成下方loader
 loader: 'happypack/loader?id=babel',
3、使用dll plugin => dynamic link library plugin，其中UglifyJS插件也可进行替换，详细请看第一条。

//首先在build文件下创建一个js文件,webpack.dll.conf.js，并写入下方代码
const path = require("path")
const webpack = require("webpack")
const UglifyJsPlugin = require('uglifyjs-webpack-plugin')
const pkg = require('../package')//引入package文件，目的就是找到依赖

module.exports = {
    // 想要打包的模块的数组
    entry: {
        // vendor: ['axios', 'vue-router', 'vue','weixin-js-sdk','element-ui','vuex']
        vendor:Object.keys(pkg.dependencies)//取出所有依赖单独打包
    },
    output: {
        path: path.join(__dirname, '../static/js'), // 打包后文件输出的位置
        filename: '[name].dll.js',//生成的文件名字 默认为vendor.dll.js
        library: '[name]_library'//生成文件的映射关系，与下面的DLLPlugin配置相对应
    },
    plugins: [
        new webpack.DllPlugin({//生成一个json文件 里面是关于dll.js的配置信息
            path: path.join(__dirname, '.', '[name]-manifest.json'),
            name: '[name]_library',//与上面output中的配置对应
            context: __dirname//上下文环境路径，必须填写，为了与DLLReferencePlugin存在于同一上下文中，否则undefined
        }),
        // 压缩打包的文件
        new UglifyJsPlugin({
            uglifyOptions: {
            compress: {
                  warnings: false
            }
          },
      }),
    ]
}

//然后在webpack.prod.conf.js和webpack.dev.conf.js中加入当前插件
new webpack.DllReferencePlugin({
          context: __dirname,//与DllPlugin中的context保持一致
          /*这个地址对应webpack.dll.conf.js中生成的那个json文件的路径，这样webpack打包的时候
          会检测当前文件中的映射，不会把已经存在映射的包再次打包进bundle.js */
          manifest: require('./vendor-manifest.json')
      }),

//在package.json中新加一条npm命令，执行webpack.dll.conf.js文件
"dll": "webpack --config ./build/webpack.dll.conf.js"
//tips：每次添加新依赖后，一定要运行npm run dll这个命令一次。

//最后在index.html中引入static/js/vendor.dll.js文件
<script src="static/js/vendor.dll.js"></script>

vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法 ？
methodsToPatch.forEach(function(method) {
    // cache original method
    // 获取原方法
    var original = arrayProto[method];
    // def方法重新定义arrayMethods的method方法，然后将新的取值方法赋值
    def(arrayMethods, method, function mutator() {
      var args = [],
        len = arguments.length;
      while (len--) args[len] = arguments[len];

      var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          // [].push(1),[].unshift(1)
          // arg = [1]
          inserted = args;
          break
        case 'splice':
          // [1,2,3].splice(0,1,1)
          // 第三个参数为插入的值
          inserted = args.slice(2);
          break
      }
      if (inserted) { ob.observeArray(inserted); }
      // 监听变化，如果不是插入操作直接循环响应
      // 如果是去除数组参数方法，触发一次notify将会重新计算
      // 如果仅仅是数字数据，任何操作只需要再次执行一次notify则可以
      // 但是如果新增的是一个对象类型，就需要重新监听
      // 为什么用角标和length属性不能监听的原因是因为无法触发obj的get方法，所以没法动态监听
      // notify change
      ob.dep.notify();
      return result
    });
  });
简单来讲，重写了数组中的那些方法，首先获取到这个数组的__ob__,也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化，然后手动调用notify，通知渲染watcher，执行update
正如该题所问，vue对push,pop,splice等方法进行了hack，hack方式很简单，如果加入新对象，对新对象进行响应式化，至于如何响应式化请参考vue源码。
举例来说对于push和unshift会推入一个新的对象到数组里(不管从前还是从后),记录这个加入的对象，并调用Observe方法将加入的对象转换成响应式对象,对于splice方法，如果加入了新对象也是将该对象响应式化。
最后一步是向外抛出数组变化，提醒观察者进行更新。

3.存在问题
对于Object.defineProperty的缺陷导致如果直接改变数组下标是无法hack的，由于此点，vue提供了$set方法，最新的解决方案当然是利用Proxy对象进行监听，但是Proxy的缺陷在于兼容性，可能会为了性能以及便利而放弃兼容性吧，一切都要看尤大的决定了。

4.ps
不知道啥时候3.0才能出来，都等到迫不及待了。

永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响？
301重定向可促进搜索引擎优化效果
从搜索引擎优化角度出发，301重定向是网址重定向最为可行的一种办法。当网站的域名发生变更后，搜索引擎只对新网址进行索引，同时又会把旧地址下原有的外部链接如数转移到新地址下，从而不会让网站的排名因为网址变更而收到丝毫影响。同样，在使用301永久性重定向命令让多个域名指向网站主域时，亦不会对网站的排名产生任何负面影响。

302重定向可影响搜索引擎优化效果
迄今为止，能够对302重定向具备优异处理能力的只有Google。也就是说，在网站使用302重定向命令将其它域名指向主域时，只有Google会把其它域名的链接成绩计入主域，而其它搜索引擎只会把链接成绩向多个域名分摊，从而削弱主站的链接总量。既然作为网站排名关键因素之一的外链数量受到了影响，网站排名降低也是很自然的事情了。

如何用 css 或 js 实现多行文本溢出省略效果，考虑兼容性 ?
单行：
overflow: hidden;
text-overflow:ellipsis;
white-space: nowrap;
多行：
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3; //行数
overflow: hidden;
兼容：
p{position: relative; line-height: 20px; max-height: 40px;overflow: hidden;}
p::after{content: "..."; position: absolute; bottom: 0; right: 0; padding-left: 40px;
background: -webkit-linear-gradient(left, transparent, #fff 55%);
background: -o-linear-gradient(right, transparent, #fff 55%);
background: -moz-linear-gradient(right, transparent, #fff 55%);
background: linear-gradient(to right, transparent, #fff 55%);
}

输出以下代码执行结果?
function wait() {
  return new Promise(resolve =>
  	setTimeout(resolve, 10 * 1000)
  )
}

async function main() {
  console.time();
  const x = wait();
  const y = wait();
  const z = wait();
  await x;
  await y;
  await z;
  console.timeEnd();
}
main();
执行wait方法是同步执行的，所以耗时是选最高的，x，y，z 的返回的结果await等于执行同步代码Promise.resolve()，await 的时候只执行同步代码

稍微改造一下就可以得到30 * 1000 ms以上的结果了
`function wait () {
return new Promise(resolve => setTimeout(resolve, 10 * 1000))
}

async function main () {
console.time()
const x = await wait()
const y = await wait()
const z = await wait()
// await x
// await y
// await z
console.timeEnd()
}

main()`

用 setTimeout 实现 setInterval，阐述实现的效果与setInterval的差异?
简单的代码实现
    function foo(){
        console.log("执行foo");
        setTimeout(foo, 1000)
    }
    foo();
    function goo(){
        console.log("执行goo");
    }
    setInterval(goo, 1000);
之前学习setInterval，设置的间隔时间过短的时候，如果代码块里的代码并没有执行完也会重新开始执行？(我一直都是这么理解的)，但使用setTimeout实现setInterval的这个效果就没这个问题，必然会把代码块中的代码运行玩后，然后才会再次调用该函数
requestAnimationFrame的兼容写法应该就是类似我这个setTimeout实现setInterval的代码
求大佬指正轻喷，本人萌新- -

算法题 ?
在一个字符串数组中有红、黄、蓝三种颜色的球，且个数不相等、顺序不一致，请为该数组排序。使得排序后数组中球的顺序为:黄、红、蓝。

例如：红蓝蓝黄红黄蓝红红黄红，排序后为：黄黄黄红红红红红蓝蓝蓝。
const stringOrder = {
    '黄':0,
    '红':1,
    '蓝':2
}
'红蓝蓝黄红黄蓝红红黄红'.split('').sort((a,b) =>stringOrder[a]-stringOrder[b] )

如何实现骨架屏，说说你的思路?
将app的默认样式写成灰色，当获取到数据之后，为body替换成新的样式
灰色的骨架屏可以是一张图片，数据取到之后再替换为dom节点
[v-cloak] { background: gray; }
哈哈哈哈把自己逗笑了
写一个基础组件，就写一个全灰色的背景块，然后所有的内容块都可以继承当前组件，只需要检测当前内容块是否加载完成，控制背景块的显示/隐藏

如何在 H5 和小程序项目中计算白屏时间和首屏时间，说说你的思路 ?
白屏时间=页面开始展示的时间点-开始请求时间点。

开始请求时间点可以通过Performance Timing.navigation Start 。那么页面开始展示的时间点怎么获取呢。已经知道渲染过程是逐步完成的，而且页面解析是按照文档流从上至下解析的，因此一般认为开始解析body的时间点就是页面开始展示的时间。所以可以通过在head标签的末尾插入script来统计时间节点作为页面开始展示时间节点。但是这种方式需要打点，因此也有很多项目为了简化白屏时间的获取会选择忽略head解析时间直接用Performance Timing.dom Loading 来表示页面开始展示的时间，即使用domloading-navigation Start来表示白屏时间。

首屏时间=首屏内容渲染结束时间点-开始请求时间点。

同样开始请求时间点可以通过Performance Timing.navigation Start获取。首屏内容渲染结束的时间点通常有以下几种方法获取：

（1）首屏模块标签标记法

适用于于首屏内容不需要通过拉取数据才能生存以及页面不考虑图片等资源加载的情况。通过在 HTML 文档中对应首屏内容的标签结束位置，使用内联的 JavaScript 代码记录当前时间戳作为首屏内容渲染结束的时间点。

（2）统计首屏内加载最慢的图片的时间

通常首屏内容加载最慢的就是图片资源，因此可以把首屏内加载最慢的图片加载完成的时间作为首屏时间。由于浏览器对每个页面的 TCP 连接数有限制，使得并不是所有图片都能立刻开始下载和显示。因此在 DOM树 构建完成后会通过遍历首屏内的所有图片标签，并且监听所有图片标签 onload 事件，最终遍历图片标签的加载时间获取最大值，将这个最大值作为首屏时间。

（3）自定义首屏内容计算法

由于统计首屏内图片完成加载的时间比较复杂。所以在项目中通常会通过自定义模块内容，来简化计算首屏时间。例如忽略图片等资源加载情况，只考虑页面主要 DOM；只考虑首屏的主要模块，而不是严格意义首屏线以上的所有内容。

可交互时间=用户可以正常进行事件输入时间点-开始请求时间点。

PerformanceTiming有一个domInteractive属性，代表了DOM结构结束解析的时间点，就是Document.ready State属性变为“interactive”

谈一谈 nextTick 的原理 ?
<template>
  <div>
    <div>{{number}}</div>
    <div @click="handleClick">click</div>
  </div>
</template>
export default {
    data () {
        return {
            number: 0
        };
    },
    methods: {
        handleClick () {
            for(let i = 0; i < 1000; i++) {
                this.number++;
            }
        }
    }
}
当我们按下 click 按钮的时候，number 会被循环增加1000次。

那么按照之前的理解，每次 number 被 +1 的时候，都会触发 number 的 setter 方法，从而根据上面的流程一直跑下来最后修改真实 DOM。那么在这个过程中，DOM 会被更新 1000 次！那怎么办？

Vue.js中的 nextTick 函数，会传入一个 cb ，这个 cb 会被存储到一个队列中，在下一个 tick 时触发队列中的所有 cb 事件。

Vue.js 肯定不会以如此低效的方法来处理。Vue.js在默认情况下，每次触发某个数据的 setter 方法后，对应的 Watcher 对象其实会被 push 进一个队列 queue 中，在下一个 tick 的时候将这个队列 queue 全部拿出来 run（ Watcher 对象的一个方法，用来触发 patch 操作） 一遍。

因为目前浏览器平台并没有实现 nextTick 方法，所以 Vue.js 源码中分别用 Promise、setTimeout、setImmediate 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。

export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
首先定义一个 callbacks 数组用来存储 nextTick，在下一个 tick 处理这些回调函数之前，所有的 cb 都会被存在这个 callbacks 数组中。pending 是一个标记位，代表一个等待的状态。
这里用setTimeout做描述（真实源码里更复杂）：
setTimeout 会在 task 中创建一个事件 flushCallbacks ，flushCallbacks 则会在执行时将 callbacks 中的所有 cb 依次执行。

watcher
上面例子中，当我们将 number 增加 1000 次时，先将对应的 Watcher 对象给 push 进一个队列 queue 中去，等下一个 tick 的时候再去执行，这样做是对的。但是有没有发现，另一个问题出现了？

因为 number 执行 ++ 操作以后对应的 Watcher 对象都是同一个，我们并不需要在下一个 tick 的时候执行 1000 个同样的 Watcher 对象去修改界面，而是只需要执行一个 Watcher 对象，使其将界面上的 0 变成 1000 即可。

那么，我们就需要执行一个过滤的操作，同一个的 Watcher 在同一个 tick 的时候应该只被执行一次，也就是说队列 queue 中不应该出现重复的 Watcher 对象。

那么我们可以用 id 来标记每一个 Watcher 对象，让他们看起来不太一样。

我们再回过头聊一下第一个例子， number 会被不停地进行 ++ 操作，不断地触发它对应的 Dep 中的 Watcher 对象的 update 方法。然后最终 queue 中因为对相同 id 的 Watcher 对象进行了筛选，从而 queue 中实际上只会存在一个 number 对应的 Watcher 对象。在下一个 tick 的时候（此时 number 已经变成了 1000），触发 Watcher 对象的 run 方法来更新视图，将视图上的 number 从 0 直接变成 1000。
首先因为目前浏览器平台并没有实现 nextTick 方法，所以 Vue.js 源码中分别用 Promise、setTimeout、setImmediate 等方式在 microtask（或是macrotasks）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件
对于实现 macrotasks ，会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout。 注意，是对实现宏任务的判断

问题来了？为什么要优先定义 setImmediate 和 MessageChannel 创建，macroTasks而不是 setTimeout 呢？
HTML5中规定setTimeout的最小时间延迟是4ms，也就是说理想环境下异步回调最快也是4ms才能触发。Vue使用这么多函数来模拟异步任务，其目的只有一个，就是让回调异步且尽早调用。而 MessageChannel 和 setImmediate 的延迟明显是小于 setTimeout的


JavaScript 运行机制详解：再谈Event Loop?
http://www.ruanyifeng.com/blog/2014/10/event-loop.html

HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。
需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。

为什么 HTTP1.1 不能实现多路复用?
HTTP1.x是序列和阻塞机制

HTTP 2.0 是多工复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。

旧的http1.1是会等 A请求完全处理完后在 处理B请求，会阻塞

另：http1.1已经实现了管道机制：即 在同一个TCP连接里面，客户端可以同时发送多个请求。http 1.0并做不到，所以效率很低

Vue 中的 computed 是如何实现的?
实质是一个惰性的watcher，在取值操作时根据自身标记 dirty属性返回上一次计算结果/重新计算值
在创建时就进行一次取值操作，收集依赖变动的对象/属性(将自身压入dep中)
在依赖的对象/属性变动时，仅将自身标记dirty致为true
在initComputed中遍历每一个computed属性，创建对应的Watcher。在Watcher实例化过程中，计算computed属性结果，会对依赖的data进行取值，从而触发data的getter进行依赖收集，将当前Watcher加入到订阅者数组中。当computed属性依赖的data改变时，会触发data的setter通知订阅者更新，这个computed会重新计算。

（算法题）求多个数组之间的交集?
function intersect(...args) {
  if (args.length === 0) {
    return []
  }
  if (args.length === 1) {
    return args[0]
  }
  return args.reduce((result, arg) => {
    return result.filter(item => arg.includes(item))
  })
}

将'10000000000'形式的字符串，以每3位进行分隔展示'10.000.000.000',多种实现方式 ?
// 德国以 . 分割金钱, 转到德国当地格式化方案即可
10000000000..toLocaleString('de-DE') 
// 寻找字符空隙加 .
'10000000000'.replace(/\B(?=(\d{3})+(?!\d))/g, '.')
// 寻找数字并在其后面加 . 
'10000000000'.replace(/(\d)(?=(\d{3})+\b)/g, '$1.')

var myNum = Number('10000000000'); //字符串转数字后就可以使用toLocaleString()啦~
var num2Str = myNum .toLocaleString(); //"10,000,000,000"
num2Str.replace(/,/g, "."); //"10.000.000.000"

手写二进制转 Base64 ?
let encodedData = window.btoa("this is a example");
console.log(encodedData); // dGhpcyBpcyBhIGV4YW1wbGU=

let decodeData = window.atob(encodedData);
console.log(decodeData); // this is a example

前端项目如何找出性能瓶颈 ?
性能瓶颈一般是表现在用户体验方面，比如页面加载过慢，动画卡顿，交互延迟等等，具体问题具体分析。
比如PM反馈说，你们这个页面怎么加载这么慢啊，好几秒才呈现，这种现象问题可能出现在请求资源过多，资源太大，没有压缩，没有缓存等等，那么就等减少http请求，压缩资源，设置缓存。
如果PM反馈说，这个列表滑动的时候加载数据一卡一卡的，那么性能瓶颈可能出现在频繁操作，数据太大等等，那么就得做懒加载，函数节流等等；
总之前端的性能瓶颈往往都是有表现的，需要针对具体表现具体分析具体解决
大数据量列表渲染的时候，比如点餐，外卖，电商分类列表等。当数据量达到一定程度且每条数据里面的都有对应的效果和图片以及操作等等。这时候上下拉的时候就会出现延迟，甚至点击无反应。
这时候就是前端(浏览器)渲染的性能瓶颈了。
当然解决的方式可以把数据切块，分块进行加载，加载到某一块的时候取某一块的数据，其他的隐藏，这样则可以解决大数据列表的问题。
为了体验好，可以把渲染区域上下两屏的数据都渲染出来，以防出现空白。

Vue 中的 computed 和 watch 的区别在哪里?
computed：计算属性

计算属性是由data中的已知值，得到的一个新值。
这个新值只会根据已知值的变化而变化，其他不相关的数据的变化不会影响该新值。
计算属性不在data中，计算属性新值的相关已知值在data中。
别人变化影响我自己。
watch：监听数据的变化
监听data中数据的变化
监听的数据就是data中的已知值
我的变化影响别人
1.watch擅长处理的场景：一个数据影响多个数据
2.computed擅长处理的场景：一个数据受多个数据影响
我总结了下，有如下几点：
功能上：computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数

使用上：computed中的函数必须要用return返回；watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要用return

性能上：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调

场景上：computed：当一个属性受多个属性影响的时候，例子：购物车商品结算；watch：当一条数据影响多条数据的时候，例子：搜索框

webpack 中 loader 和 plugin 的区别是什么?
loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。

plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务
一、webpack的打包原理

识别入口文件
通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖)
webpack做的就是分析代码，转换代码，编译代码，输出代码
最终形成打包后的代码
二、什么是loader

loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中

处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行

第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码

三、什么是plugin

在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。

四、loader和plugin的区别

对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程

plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务


v-if、v-show、v-html 的原理是什么，它是如何封装的？
v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；
v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；
v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值

二分查找如何定位左边界和右边界 ？
二分查找基础代码
//递归查找
function erfen_digui(arr, val, left = 0, right = arr.length - 1) {
        if (left > right) {
          return -1;
        }
        let cent = Math.floor((right + left) / 2);
        if (arr[cent] === val) {
          return `最终查找结果下标为${cent}`;
        } else if (arr[cent] > val) {
          right = cent - 1;
        } else {
          left = cent + 1;
        }
        return erfen_digui(arr, val, left, right);
      }
//非递归查找
      function erfen_feidigui(arr, val) {
        let left = 0,
          right = arr.length - 1;
        while (left <= right) {
          let cent = left + Math.floor((right - left) / 2);
          if (arr[cent] === val) {
            return `最终查找结果下标为${cent}`;
          } else if (arr[cent] > val) {
            right = cent - 1;
          } else {
            left = cent + 1;
          }
        }
        return -1;
      }

//左边界查找（查找第一个元素）
function erfen_digui(arr, val, left = 0, right = arr.length - 1) {
        if (left > right) {
          return -1;
        }
        let cent = Math.floor((right + left) / 2);
        if (arr[cent] === val) {
          /****************改动点********************/
          if (arr[cent - 1] === val) {
            right = cent - 1;
          } else {
            return `最终查找结果下标为${cent}`;
          }
          /*****************************************/
        } else if (arr[cent] > val) {
          right = cent - 1;
        } else {
          left = cent + 1;
        }
        return erfen_digui(arr, val, left, right);
      }

// 二分查找右边界（查找最后一个元素）
function erfen_digui(arr, val, left = 0, right = arr.length - 1) {
        if (left > right) {
          return -1;
        }
        let cent = Math.floor((right + left) / 2);
        if (arr[cent] === val) {
          /****************改动点********************/
          if (arr[cent + 1] === val) {
            left = cent + 1;
          } else {
            return `最终查找结果下标为${cent}`;
          }
          /*****************************************/
        } else if (arr[cent] > val) {
          right = cent - 1;
        } else {
          left = cent + 1;
        }
        return erfen_digui(arr, val, left, right);
      }

详解JS函数柯里化？
维基百科上说道：柯里化，英语：Currying(果然是满满的英译中的既视感)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。
柯里化一共有三大作用，分别是：
参数复用
一、参数复用
　　所谓参数复用，就是利用闭包的原理，让我们前面传输过来的参数不要被释放掉。看一下下面这段代码就显而易见了：
提前确认
　二、 提前确认
　　这一特性经常是用来对浏览器的兼容性做出一些判断并初始化api，比如说我们目前用来监听事件大部分情况是使用addEventListener来实现的，但是一些较久的浏览器并不支持该方法，所以在使用之前，我们可以先做一次判断，之后便可以省略这个步骤了。
var on = (function() {
     if (document.addEventListener) {
         return function(element, event, handler) {
             if (element && event && handler) {
                 element.addEventListener(event, handler, false);
             }
         };
     } else {
         return function(element, event, handler) {
             if (element && event && handler) {
                 element.attachEvent('on' + event, handler);
             }
         };
     }
 })();
延迟运行
js中的bind这个方法，用到的就是柯里化的这个特征。
Function.prototype.bind = function (context) {
    var _this = this
    var args = Array.prototype.slice.call(arguments, 1)
 
    return function() {
        return _this.apply(context, args)
    }
}

// 支持多参数传递
function progressCurrying(fn, args) {

    var _this = this
    var len = fn.length;
    var args = args || [];

    return function() {
        var _args = Array.prototype.slice.call(arguments);
        Array.prototype.push.apply(args, _args);

        // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数
        if (_args.length < len) {
            return progressCurrying.call(_this, fn, _args);
        }

        // 参数收集完毕，则执行fn
        return fn.apply(this, _args);
    }
}
最后再扩展一道经典面试题
// 实现一个add方法，使计算结果能够满足如下预期：
add(1)(2)(3) = 6;
add(1, 2, 3)(4) = 10;
add(1)(2)(3)(4)(5) = 15;

function add() {
    // 第一次执行时，定义一个数组专门用来存储所有的参数
    var _args = Array.prototype.slice.call(arguments);
    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
    var _adder = function() {
        _args.push(...arguments);
        return _adder;
    };
    // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
    _adder.toString = function () {
        return _args.reduce(function (a, b) {
            return a + b;
        });
    }
    return _adder;
}

add(1)(2)(3)                // 6
add(1, 2, 3)(4)             // 10
add(1)(2)(3)(4)(5)          // 15
add(2, 6)(1)                // 9

// 阻止按钮重复提交
新建一个文件，directive.js    使用的地方导入import "./util/directive"   组件上使用<wan-button v-button></wan-button>
Vue.directive("button", {
    bind: function (el, binding, vnode) { // 每当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次
        function clickHandler(e) {
            // 这里判断点击的元素是否是本身，是本身，则返回
            if (el.contains(e.target)) {
                $(el).attr("disabled", true);
                setTimeout(() => {
                    $(el).attr("disabled", false);
                }, 1500)
                return false;
            }
            // 判断指令中是否绑定了函数    // 如果绑定了函数 则调用那个函数，此处binding.value就是handleClose方法
            if (binding.expression) {
                binding.value(e);
            }
        }
        // 给当前元素绑定个私有变量，方便在unbind中可以解除事件监听
        el.__vueClickOutside__ = clickHandler;
        document.addEventListener('click', clickHandler);
    },
    unbind(el, binding) {   // 解除事件监听
        document.removeEventListener('click', el.__vueClickOutside__);
        delete el.__vueClickOutside__;
    },
})

bootstrap的栅格系统为什么是12列，有没有18列，24列等等啊，采用12列有什么好处？
因为12是1，2，3，4，6的最小公倍数，所以12列栅格系统相对较灵活，支持将一行分成1列，2列，3列，4列，6列。
若是想要支持5列，那1，2，3，4，5的最小公倍数是60，而60这个数对于栅格系统来说显然太大了。
18能均分4列不？24能做的12都能做，所以12是最好的选择。


//addEventListener当第三个参数设置为true就在捕获过程中执行，反之就在冒泡过程中执行处理函数。
//DOM0级事件绑定
//给同一个元素的同一个事件行为绑定不同的函数,后面绑定的方法会覆前面的方法
//    box.οnclick=function () {
//        console.log(1);
//    }
//    box.οnclick=function(){
//        console.log(2);
//    }

//DOM2级绑定不能给同一个元素的同一个事件行为绑定同一个方法
//    function fn(){
//        console.log(3);
//    }
//    box.addEventListener('click',fn,false);
//    box.addEventListener('click',fn,false);

//DOM级事件绑定可以给同一个元素的同一个事件行为绑定多个方法,谁先绑定谁先执行
//    function fn1(){
//        console.log(4);
//    }
//    function fn2(){
//        console.log(5);
//    }
//    box.addEventListener('click',fn1,false);
//    box.addEventListener('click',fn2,false);

function fn() {
    console.log(6);
    console.log(this); //这里面的this指向window
}
box.attachEvent('onclick', fn);
box.attachEvent('onclick', fn);

// 1. 顺序问题； attachEvent绑定的事件方法顺序是倒序的；
// 2. 重复绑定的问题；可以给同一个元素的同一个事件绑定相同的方法；
// 3. 函数方法中的this指向window，不指向绑定的那个元素；

function addEvent(el, name, fn) {
    return el.addEventListener ?
        el.addEventListener(name, fn, false) : //在火狐中会执行这一句
        el.attachEvent('on' + name, fn); //在ie中执行这一句
}

柯粒化的特点  参数复用   提前确认   延迟执行

谈谈This对象的理解
this总是指向函数的直接调用者（而非间接调用者）
如果有new关键字，this指向new出来的那个对象
在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window

事件模型
W3C中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段（targetin）、冒泡阶段（bubbling）
冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发
捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发
DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件
阻止冒泡：在W3c中，使用stopPropagation()方法；在IE下设置cancelBubble = true
阻止捕获：阻止事件的默认行为，例如click - <a>后的跳转。在W3c中，使用preventDefault()方法，在IE下设置window.event.returnValue = false

new操作符具体干了什么呢?
创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型
属性和方法被加入到 this 引用的对象中
新创建的对象由 this 所引用，并且最后隐式的返回 this

那些操作会造成内存泄漏？
内存泄漏指任何对象在您不再拥有或需要它之后仍然存在
setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏
闭包使用不当

offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别
offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同
clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条
scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸

npm install -S -D -g 有什么区别

npm install module_name -S    即    npm install module_name --save    写入dependencies
npm install module_name -D    即    npm install module_name --save-dev 写入devDependencies
npm install module_name -g 全局安装(命令行使用)
npm install module_name 本地安装(将安装包放在 ./node_modules 下)

dependencies与devDependencies有什么区别呢？
devDependencies 里面的插件只用于开发环境，不用于生产环境
dependencies 是需要发布到生产环境的
有点儿不好理解，别怕，举个例子就好：
你开发一个前端项目，在项目中你需要使用gulp构建你的开发和本地运行环境,这时你就要放到dependencies里。gulp是你用来压缩代码，打包等需要的工具，程序实际运行的时候并不需要，所以放到dev里就ok了。
你写程序要用element-ui,生产环境运行项目时肯定要用到element-ui,这时element-ui就应该安装到dependencies中去。

/deep/ 样式
深度选择器，Vue单文件组件中scope样式，对子组件会不生效。如果想让某些样式在子组件里面生效，可以使用/deep/
<style lang="less" scoped>
/deep/ .el-checkbox {
  min-width: 180px;
  margin-bottom: 4px;
}  
</style>

滚动条消失的问题
和高度设置有关，如果，注意用 min-height: calc(100vh - top高度)

#遍历对象优雅写法
let obj = {
  a: 1,
  b: 2
}
Object.keys(obj).forEach(key => {
  cosnole.log(key, obj[key])
})

eslint保存时自动fix
vscode默认的autofix只能fix .js的文件，无法fix .vue的文件，加入下面的配置即可

// config
{
  "edit.formatOnSave": false,   // 取消自带fix，使用eslint自动保存fix
  "eslint.autoFixOnSave": true, // 每次保存的时候将代码按eslint格式进行修复
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    {
      "language": "vue",
      "autoFix": true
    },
    "html"
  ]
}

全局修改el菜单样式不影响其他
.vue单文件组件style元素加上scope后，当前页面修改el-tree的默认样式无效需要去掉scope，将样式暴露到全局，但对全局可能有影响，解决方法是最外层使用特殊的class包裹

<style lang="less">
  .root-menu-left {
    /* el样式修改 */  
  }
</style>

v-cloak 指令
防止由于网络原因vue.js未渲染时，页面显示空白的问题

// 当编译完成后，v-cloak属性会被自动移除。
[v-cloak] {
  display: none;
}
<div v-cloak>
  {{message/}}
</div>

eltree 懒加载问题
懒加载每次加载数据都是从后台搜索而来，对于复杂的逻辑，建议用文字来整理，按步骤分解，不管逻辑多复杂，条理都会很清晰。

#eltree highlight 属性
加上后，当前选中的背景色会稍微深一点

URLSearchParams() 查询字符串处理
https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams

var searchParams = new URLSearchParams()
searchParams.append('a', 1212)
searchParams.append('b', 'xxx')
searchParams.toString()   // "a=1212&b=xxxx"

// 结合fromEntries函数，将查询字符串转对象
Object.fromEntries(new URLSearchParams('foo=bar&baz=qux'))

前端ajax请求时，设置Cookie请求头无效。
W3c规定，当请求的header匹配以下不安全的字符时，将被终止
...
Cookie
Host
Referer
User-Agent
...

elementUI 全局触发消息
// $message(), $alet()
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'

Vue.use(ElementUI)

// 注意：引入方式不是 .use
Vue.prototype.$message = ElementUI.Message
Vue.prototype.$alert = ElementUI.MessageBox.alert

this.$message({
  type: 'error', // warning
  message: '这是一条消息' 
})

this.$message.error(e.message)

Vue中img的src是动态参数时不显示
解决方法：使用require来加载图片
<img :src="item.avatarUrl?item.avatarUrl:require('默認展示圖片地址')" /> 

画比1px还细的线或border
一般使用transform缩小0.5倍来实现，如果是border先将元素放大2倍，再缩小0.5倍，放大缩小后还是以放大的空间来占位，使用positon:absolute脱离标准文档流，就不会有两倍的占位了。
/* 比1px还细的线 */
.thinline {
  height: 1px;width:100%;
  -webkit-transform-origin: 0 0;
  transform-origin: 0 0;
  -webkit-transform: scaleY(0.5);
  transform: scaleY(0.5);
  background:#ccc;
}
#部分安卓机型scale后border显示不全的问题
解决方法是将样式用style写在内联样式里，刚开始不相信写成内联样式就可以解决这个问题，但实践后发现确实可以解决这个问题。

flex布局align-self使用场景
一般flex布局后，item子项某一个高度比较高，其他子项的高度也会是高度最高的子项高度。设置border时会特别明显。如果需要让item高度适应内容，就可以使用 align-self: flex-start。
https://www.yuque.com/guoqzuo/piylht/kg7660#45717a91

Number.prototype.toLocaleString()
返回千分位逗号分隔的字符串.

// MDN文档: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString
var number = 12123
number.toLocaleString() // "12,123"
number.toLocaleString('en', {style:'currency', currency:'USD'}) // "$12,123.00"
number.toLocaleString('cn', {style:'currency', currency:'CNY'}) // "￥12,123.00"

Mac zip压缩加密
zip -e 目标文件名.zip 需要加密的zip文件
# 输入上面的命令后，会提示输入两次密码
更多zip命令相关用法，可以在控制台使用 man zip 查看文档

vscode git插件 GitLens
vscode插件名称: "GitLens -- Git supercharged"，安装后点击某一行代码，都会显示最近的git提交记录，非常好的一个git插件

toFixed() 对number取整或保留指定小数位
/**
 * Number.prototype.toFixed()
 * The toFixed() method formats a number using fixed-point notation.
 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed
 * 
 * 使用方法：
 * numObj.toFixed(digits) 
 * @params { Integer } digits 可选 保留精度，为空时，默认为0，即取整
 * @returns { String } 返回转换后的字符串
 */
var a = 1.235
a.toFixed()  // "1"
typeof a.toFixed()  // "string"
a.toFixed(2) // "1.23"
重点来了,tofixed()需要注意的地方:

四舍五入不精确的问题，类似于 0.1 + 0.2 === 0.3 不成立
var a = 0.15
var b = 0.25
a.toFixed(1) // "0.1"  注意这里四舍五入异常
b.toFixed(1) // "0.3"  这里四舍五入又是成功的

// 如果希望精准的保留1位小数可以   Math.round(a*10) / 10, 如果是两位 100，n位  Math.pow(10, n)
Number.prototype.myToFixed = function (num) {
  // 在原型方法注入 myToFixed函数，这里怎么获取当前的值呢？可以使用this
  // 注意 this 是一个Number对象
  // var a = Number(2)  // 2  typeof a 为 "number"
  // var b = new Number(2) // Number{2}  typeof b 为 "object"
  // 获取值需要使用 b.valueOf()  // 2

  // 如果没有传参数
  if (num === undefined) {
    return Math.round(this.valueOf())
  }

  // 如果有传参，且为整数
  if (Number.isInteger(num)) {
    var tempCount = Math.pow(10, num)
    var tempNum = Math.round(this.valueOf() * tempCount) / tempCount
    // 这一步其实已经就可以了。但对于保留整数后面两位小数来说，会有bug
    // var a = 2
    // a.myToFixed(2)  =>  2  而不是 2.00
    // 需要再转换下
    return tempNum.toFixed(num)
  } else {
    throw new Error('参数必须是number类型，且必须是整数')
  }
}
负数的运算符优先级问题
-2.12.toFixed(1) // -2.1  注意返回的字符串，被 - 操作后就是number了
(-2.12).toFixed(1) // "-2.1" 

CI/CD/CO
CI持续集成 => CD持续交付 => CO持续运营

npm设置私有仓库
npm config set registry http://xxx.xx.xx.xx:4873/     

vue性能优化 - webpack包体积优化
安装 webpack-bundle-analyzer npm包
# 安装包
npm install webpack-bundle-analyzer --save-dev
在package.json的scripts加入对应的命令，运行npm run report 即可build，并在dist目录生成report.html，打开就可以各个模块包对应的大小，这样就可以开始优化了
scripts: {
  "report": "vue-cli-service build --report"
}
路由都弄成懒加载，js懒加载可以使用import()，如果使用import xx from 'xx'，会直接打包到主包，就需要弄成懒加载的逻辑。但如果使用该js，怎么判断js已懒加载完？setTimeout 1s后再调用，弱网呢？怎么监听？这就需要了解懒加载的逻辑了，示例如下：
<!-- 监听是否加载完成 -->
<!-- 在浏览器中，import 语句只能在声明了 type="module" 的 script 的标签中使用。-->
<script type="module">
  let myModule = () => import('./testModule.js')
  
  // testModule.js   内容 export default { a: 1, b: "test" }

  // 类似于路由组件component懒加载逻辑。myModule仅是一个函数，返回promise，需要调用时 myModule().then() 即可
  window.onload = () => {
    console.log('onload')

    // dom已加载，3秒后加载模块
    setTimeout(() => {
      console.log(myModule, typeof myModule) // () => import('./testModule.js') "function"
      // myModule() 函数执行后，返回promise
      myModule().then((res) => {
        console.log('模块加载成功', res) // 加载成功 Module {Symbol(Symbol.toStringTag): "Module"}
        let data = res.default // {a: 1, b: "test"}
        console.log(data.a) // 1
      },(e) => {
        console.log('import 加载异常')
      })
    }, 3000)
  }
</script>

vuex设置后立即调用this.$router.back()按钮无法点击的问题
今天测试机iPhone 7 plus，系统大概是iOS 11.3，vuex mutation操作后，立即调用 this.$router.back() 会导致页面里的下一步无法点击。

// 解决方法
// vuex mutation操作 =>  this.$nextTick(() => { 将 this.$router.back() 放到这里即可 })

html2canvas 生成图片时，background-image模糊的问题
PC端一般不会出现这个问题，主要是移动端，有两种解决方法：

使用固定宽度，不要使用百分比单位(比如 1500px)
用 img 标签使用 absolute 定位做背景，不使用background-image
#postcss-pxtorem px自动转rem怎么保持使用px
如果vue-cli3中配置了postcass-pxtorem，css中写的px单位都会自动转为rem，如果需要固定px，而不是转为rem，有两种方法

 /* 使用Px 或 PX */
 .ignore {
   border: 1Px solid;
   border-width: 2PX;
 }
 
 长英文单词不换行的问题
word-break: break-all; 或者 word-wrap: break-word;

<head>
  <style>
    .sec {
      width: 200px;
      margin: 20px;
      border: 1px solid #ccc;
    }
    .fix1 {
      word-break: break-all;
    }
    .fix2 {
      word-wrap: break-word;
    }
  </style>
</head>
<body>
  <div class='sec'>
    我是汉字 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa我是汉字
  </div>
  <div class='sec fix1'>
    我是汉字 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa我是汉字
  </div>
  <div class='sec fix2'>
    我是汉字 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa我是汉字
  </div>
</body>

iOS环境下点击输入框页面被顶起不能自动回弹底部的问题
参考：https://blog.csdn.net/YY110621/article/details/87919966

解决方法：在对应的input元素加 @blur 事件，input失去焦点时，手动滚动页面 window.scroll(0,0)

npm install --save 与 --save-dev的区别
参考：https://www.cnblogs.com/limitcode/p/7906447.html

#npm install moduleName
安装模块到项目node_modules目录下。
不会将模块依赖写入devDependencies或dependencies 节点。
运行 npm install 初始化项目时不会下载模块。
#npm install -g moduleName
安装模块到全局，不会在项目node_modules目录中保存模块包。
不会将模块依赖写入devDependencies或dependencies 节点。
运行 npm install 初始化项目时不会下载模块。
#npm install -save moduleName
安装模块到项目node_modules目录下。
会将模块依赖写入dependencies 节点。
运行 npm install 初始化项目时，会将模块下载到项目目录下。
运行npm install --production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。
#npm install -save-dev moduleName
安装模块到项目node_modules目录下。
会将模块依赖写入devDependencies 节点。
运行 npm install 初始化项目时，会将模块下载到项目目录下。
运行npm install --production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。
对于只有在开发中使用的，比如node中间件、gulp、压缩css、js的模块，可以使用 --save-dev形式安装，如果线上代码必须依赖的模块，需要使用--save

安卓 input键盘弹起导致底部按钮也被抬起
监听onresize，如果之前的视窗高度不为

let oriH = document.documentElement.clientHeight;
window.onresize = () => {
  if (document.documentElement.clientHeight < oriH) {
    document.getElementById('bttombtn').style.display = 'none';
  }else{
    document.getElementById('bttombtn').style.display = '原来的显示方式';
  }
})

npm查询包信息、安装指定版本
# npm 查询某个包版本
npm view 某个包名
# 安装指定版本
npm install 某个包名@版本号

vue组件里click事件监听问题
之前在看JS高程3里面有一个知识点，就是当多个子元素需要绑定click事件时，大量添加处理程序，会影响性能，尽量少添加处理事件。但写vue习惯后，突然忘了这一点，其实vue监听事件我们也可以遵循这个原则：把事件放到其父元素上监听，然后通过 data-key属性来指定每个子元素对应的值。e.target.getAttribute('data-key')有值就表示子元素点击了

Reflect.deleteProperty
删除对象的某个属性
delete obj.name
Reflect.deleteProperty(obj, 'name')  //更优雅

vue组件updated钩子使用场景
子组件的列表数据会根据接口请求的数据来刷新，当列表数据更新后，会调用子组件updated钩子函数，我们可以在这里里处理列表数据刷新后的一些操作。比如清除所有focus状态，滚动页面

一般data每改动一次，就会触发一次updated钩子函数，对于data属性比较多的情况，可能会触发上百次的updated钩子函数，这种情况就不要使用updated了，它适用于data属性比较少的情况。

滚动到dom底端对齐
element.scrollIntoView(false) 底端对齐，true顶端对齐

#element.classList.add或remove
js原生class的添加和移除

document.getElementById("myDIV").classList.add("mystyle");
document.getElementById("myDIV").classList.remove(“mystyle");

vuex页面刷新后还原的问题
参考： https://blog.csdn.net/chen123789hkb/article/details/90175607

思路：存到storage, 再取出

//刷新保存状态
if (sessionStorage.getItem("store")) {
  store.replaceState(
    Object.assign(
        {},
        store.state,
        JSON.parse(sessionStorage.getItem("store"))
    )
  );
  sessionStorage.removeItem("store")
}

//监听，在页面刷新时将vuex里的信息保存到sessionStorage里
window.addEventListener("beforeunload", () => {
  sessionStorage.setItem("store", JSON.stringify(store.state));
});

懒加载时 import 里面不能是变量
当出现路由组件按需加载时，import里面开头不能是变量，webpack编译会无法加载对应的组件

// `前面加写死的字符串+${变量字符串}` 是可行的，会加载path目录下的所有
{ 
  path: '/path',
  // components: () => import(`${myFile}`)  // 找不到组件路径
  components: () => import(`./path/${myFile}`)  // ok
}

:not 和 :nth 混用的问题
:not() 不支持在其参数中使用其他伪类。例如，h1:not(p:first-of-type) 不能匹配任何元素，所以不能混用，额外加个class吧

'?.' 与 '??' 操作符
Optional chaining operator(?.) 与 Nullish coalescing Operator(??) 目前正式进入 stg4，确定会成为ES2020标准

Optional chaining operator(?.)
可选链操作符，阮一峰ES6入门里称之为"链判断运算符"，作用：当对象的属性或方法不存在时，需要先判断是否有值再使用。对于比较多层级的子属性判断就更复杂了，可选链操作符用于简化该场景的写法

// 示例1：当obj.sayHi存在，则执行该函数
obj.sayHi && obj.sayHi()
// 简化写法:
obj.sayHi?.() 

// 示例2: 如果当user.address为undefined，再访问子集元素会报错
var street = user.address ? user.address.street : undefined
// 简化写法: 
var street = user.address?.street

// 示例3
var argName = 'name'
obj?.[argName] 

// 语法
obj?.prop       // optional static property access
obj?.[expr]     // optional dynamic property access
func?.(...args) // optional function or method call

Nullish coalescing Operator(??)
Null判断运算符，可能会出现问题的场景:

// 示例
const response = {
  settings: {
    nullValue: null,
    height: 400,
    animationDuration: 0,
    headerText: '',
    showSplashScreen: false
  }
};

// 一般需求是，如果某个值非null 或undefined 就使用默认值
const undefinedValue = response.settings.undefinedValue || 'some other default'; // result: 'some other default'
const nullValue = response.settings.nullValue || 'some other default'; // result: 'some other default'

// 但 || 这种写法，只要左侧为false(比如(''、0、false))，也会使用默认值 
const headerText = response.settings.headerText || 'Hello, world!'; // Potentially unintended. '' is falsy, result: 'Hello, world!'
const animationDuration = response.settings.animationDuration || 300; // Potentially unintended. 0 is falsy, result: 300
const showSplashScreen = response.settings.showSplashScreen || true; // Potentially unintended. false is falsy, result: true

?? 就是为了解决这种问题需求的，只有当左侧值为null或undefined，才使用右侧的默认值

const undefinedValue = response.settings.undefinedValue ?? 'some other default'; // result: 'some other default'
const nullValue = response.settings.nullValue ?? 'some other default'; // result: 'some other default'
const headerText = response.settings.headerText ?? 'Hello, world!'; // result: ''
const animationDuration = response.settings.animationDuration ?? 300; // result: 0
const showSplashScreen = response.settings.showSplashScreen ?? true; // result: false

将对象转换为查询字符串
let obj = {a: 1, b: 2}
let queryParams = new URLSearchParams()
Object.entries(obj).forEach(([key, value]) => {
  queryParams.append(key, value)
})
console.log(queryParams.toString())

目录树自动生成treer
npm  treer包用来生成文件夹树形结构 https://github.com/derycktse/treer

failed at the phantomjs-prebuilt@2.1.16 intsall script
使用 npm install —ignore-scripts 忽略package.json中设置的脚本，意思就是避免package.json中的脚本影响包的正常安装。

The --ignore-scripts argument will cause npm to not execute any scripts defined in the package.json. See npm-scripts.
https://docs.npmjs.com/cli/install

can't find module './build/Release/node_sleep.node'
看了具体报错是sleep包引起了，到node_modules里面对应的目录查看，发现根本就没有build目录

解决方法：之前的版本是5.2.4，修改package.json将版本改为5.1.1，让后删除package-lock.json 再npm install就ok 了

npm设置下载源
查看当前npm配置项
npm config list # 查看当前npm配置项，包括源(registry)信息
修改源
# 设置源
npm config set registry http://registry.npm.taobao.org

kevindeMacBook-Air:svnclone kevin$ npm config -h
npm config set <key> <value>
npm config get [<key>]
npm config delete <key>
npm config list [--json]
npm config edit
npm set <key> <value>
npm get [<key>]

alias: c

git clone 大文件仓库超时问题
如果仓库太大，clone超时，可以使用depth参数

git clone --depth=1 git://someserver/somerepo

# depth用于指定克隆深度，为1即表示只克隆最近一次commit.

# 参考:
# https://segmentfault.com/q/1010000007700727

sessionStorage和localstorage的区别
sessionStorage关闭浏览器后会消失，localstorage不会

同一页面多个相同组件 Object.assgin问题
当一个页面引入多个相同的子组件，传入不同的对象值时，不要使用Object.assign，不然可能会出现首次赋值ok，后面的赋值都为 {} 的问题 当前页面有效，但子组件里面值都是{}。直接赋值就可以

数组排序sort值有负数时排序异常
正常情况使用 sort 是好用的，但如果有负数时，会有问题
// 
var arr = [5, -11, -10] 
arr.sort() // [-10, -11, 5]
// 明显上面的结果是有问题的，默认的排序遇到负数就不正确了
// 这就需要自定义排序了
arr.sort((a, b) => a - b) // [-11, -10, 5]

node path.resolve()
koa静态文件服务中间件的实现里，需要将当前路径 __dirname 与用户传入的路径合并为一个绝对路径，就可以使用path.resolve函数

The path.resolve() method resolves a sequence of paths or path segments into an absolute path.
const path = require('path')
path.resolve('/foo/bar', './baz');
// Returns: '/foo/bar/baz'
path.resolve('/foo/bar', '/tmp/file/');
// Returns: '/tmp/file'
let dirPath = './public'
path.resolve(__dirname, dirPath)

forEach遍历开始后，无法停止后面的遍历，无法终止执行函数。for里面可以通过break来结束循环，return结束函数。对于需要遍历到匹配的数据就退出的情况，就需要使用for了

很清奇的操作：使用抛异常的方式，来结束forEach循环
// 参考：https://www.cnblogs.com/Marydon20170307/p/8920775.html
try {
  var array = ["first","second","third","fourth"];
  // 执行到第3次，结束循环
  array.forEach(function(item,index){
      if (item == "third") {
          throw new Error("EndIterative");
      }
      alert(item);// first,sencond
  });
} catch(e) {
    if(e.message!="EndIterative") throw e;
};

if else较多时可使用策略模式
// if else 
if () {
  a
} else if () {
  b
} else if () {
  c
}
// 更优雅的写法，策略模式
// 更多策略模式，策略模式表单验证可参考：JS设计模式与开发实战 第五章p82
let rules = [
  'a': () => { a },
  'b': () => { b },
  'c': () => { c },
]
rules[name]()

element怎么动态改变校验rules且实时生效
需要动态改变rules场景，有两个功能点：
某个checkbox的值改变，有部分字段需要在必须和可选间切换
某个cascader组件值改变时，需要动态切换部分字段（有删有减）
需要注意的地方
可选和必选切换，只需要改变rules里的require属性，true和false之间切换（我之前直接暴力删rule里的fields，这种方法不能关闭原来必选时触发的错误提示）
对于动态修改rules后，必选的小红星以及之前的错误信息还在的问题，需要完全改变rules的值，才能重新触发校验，使前端页面更新
// 强制触发表单校验更新
this.rules = JSON.parse(JSON.stringify(this.rules))

axios文件上传进度及后台接收demo
axios的config参数里，可以传入onUploadProgress参数来接收upload进度事件，在koa处理时使用 post-bodyparser 可以很好的解析 multipart/form-data 数据
<!-- 前端HTML -->
<body>
  <div>
    <input type="file" name="file" id="test">
    <div id="progressDiv"></div>
  </div>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <script>
    let fileInput = document.getElementById('test')
    let progressDiv = document.getElementById('progressDiv')

    // 当input文件输入框值改变时
    fileInput.onchange = () => {
      let file = fileInput.files[0]
      this.uploadFile(file)
    } 

    // 上传文件到后台
    async function uploadFile(file) {
      let fd = new FormData()
      fd.append('file', file)
      fd.append('type', 'mask')
      try {
        let payload = fd
        let res = await axios.post('/upload', payload, {
          // axios 接收进度事件文档
          // https://github.com/axios/axios#request-config
          onUploadProgress: function (progressEvent) {
            // {loaded: 1687552, total: 35353356, ...}
            console.log('接收到进度事件', progressEvent)
            progressDiv.innerHTML = `
              <div>上传中，当前进度：${((progressEvent.loaded / progressEvent.total) * 100).toFixed(2) }% </div> 
              <div>文件大小: ${progressEvent.loaded}/${progressEvent.total}
            `
          },
        })
        console.log(res)
      } catch(e) {
        cosnoel.error(e)
      }
    }
  </script>
</body>
koa后端接收处理 upload.js

const Koa = require('koa')
const Router = require('koa-router')
const static = require('koa-static')
const BodyParser = require('post-bodyparser')

const router = new Router()
const app = new Koa()

app.use(static(__dirname + '/'))

router.post('/upload', async (ctx, next) => {
  console.log('upload', ctx.url)
  let { req } = ctx.request
  const parser =  new BodyParser(req);
  let body = await parser.formData()
  console.log(body)
  ctx.body = body
})

app.use(router.routes())

app.listen(3000)

Object.entries()遍历顺序和for...in的遍历顺序一致。for...in 以任意顺序遍历一个对象除Symbol以外的可枚举属性

来看一个示例:

var a = {
    1:"a",
    7:"b",
    4:"c",
    5:"d",
    "-3":"e",
    f:"f",
    "2.2":"g",
    6:"h",
    0:"i",
    "2" : "j"
};
for (key in a) {
  console.log(key)  
}
// 在chrome、safari、火狐浏览器中结果一致
// 0 1 2 4 5 6 7 -3 f 2.2 
再来个例子，都是字符串的情况

var category = {
  'web': 1,
  '微信小程序': 2, 
  '数据库': 3,
  '观点': 4,
  'iOS': 5,
  'UNIX环境高级编程': 5,
  'C语言': 6
}
// 调整上面的属性顺序，均按照定时时的顺序来，以属性定义的先后顺序来
for (var key in category) {
  console.log(key)  
}
再来个例子，属性都可以转换为数字的情况，这样就会按数字属性的大小来排序了

var nums = {
  3: 1,
  1: 2, 
  4: 3,
}
// 调整上面的属性顺序，均按照定时时的顺序来，以属性定义的先后顺序来
for (var key in nums) { 
  console.log(key)  // 1 3 4
}

网页dark mode(深色模式)适配
微信最近推出了深色模式，我试了下，手机切换时页面效果样式是实时刷新的。于是就想着web怎么能够监听深色模式，并设置样式。查了资料后，在Stack Overflow上找到了答案

通过css里的媒体查询就能适配深色模式，先来看看怎么用js获取当前是否是深色模式

// 获取当前是否是深色模式
// window.matchMedia('(prefers-color-scheme: dark)').matches
window.matchMedia && console.log('Is dark mode: ', window.matchMedia('(prefers-color-scheme: dark)').matches)

// 用js监听深色模式的切换事件
window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => {
  console.log('dark mode change，已' + (event.matches ? '进入': '退出') + 'dark mode')
})
window.matchMedia到底是用来做什么的？我查了下mdn，发现了这样一个示例

let mql = window.matchMedia('(max-width: 600px)');

document.querySelector(".mq-value").innerText = mql.matches;
从这个例子看，大概就知道怎么用css来支持dark模式了吧，就是加一个类似小屏适配的一个媒体查询样式，来看个例子

/* dark mode support */
@media (prefers-color-scheme: dark) {
  body {
    background-color: black;
    color: #aaa;
  }
  
  body .content article, header, aside > div, footer  {
    border-color: #333;
    color: #aaa;
    background-color: black;
    box-shadow: 0 0 10px #333;
  }
}
深色模式下，一般将背景调暗，字体设置为偏白色即可。zuo11.com 已用上面的方法适配了深色模式，

Node.js的核心用处及应用场景
打包构建、工程化，主要依赖基础的fs模块，文件读写，如xxx-cli(脚手架)、webpack、parcel、hexo，node在打包构建、前端工程化这块基本影响了整个前端的开发过程，各框架基本都有基于node的cli，快速生成脚手架，使开发更加高效、规范。

写后台接口，主要依赖基础的http模块，处理请求和响应，如 express.js、koa.js，一般主要用于模拟假数据接口, 调UI、交互效果以及做一些请求响应方面的自测

综合应用：获取数据+渲染页面(高并发、高性能)，koa.js对于开发商业化应用来说还是比较单薄，egg.js基于koa做了一些增强，让node也可以做企业级应用。阿里的使用场景就是一个很好的例子，基础设施大部分采用 Java 实现，变化较少，有事务要求的 Business Services 通常使用 Java。而Node主要用于替代过去php、jsp使用场景, 用在需要快速迭代，需求变化非常快的用户侧。node已经经受了阿里双11的考验，技术上是可行的。

题外话：个人认为综合应用这块，自己玩玩还可以，小团队或node不是非常强的技术团队尽量不要尝试，阿里能做好这块是因为国内顶尖的node方面人才基本都在阿里，经过多年实践踩坑，拥有相对完善的node基建和生态。目前市面上前端里node强的比较少，饿了么为了招node服务端开发，还专门写了个node相关的面试教程。可想而知这方面人才有多少。

node支持高并发的原因:

node.js基于异步I/O，接收到请求后，直接开一个I/O线程去执行，然后就不管了，立即继续执行主线程。等I/O线程执行完成后，直接执行对应的回调函数即可。省去了许多等待请求的时间
事务驱动，主线程通过event loop事件循环触发的方式来运行程序，这一条暂时还不是很理解，先写上~

git commit 提交信息有误怎么修改
如果不小心提交了，但没有push，可以使用下面的命令来修改上一次的commit信息

git commit --amend -m 'xxx'

他人提交了package-lock.json的更新导致拉取时和本地冲突
一般在npm install 时会修改package-lock.json文件，我一般不会提交这个更新，但今天发现有人提交。我拉取时，提示这个文件冲突，导致拉取不下来，我又不想提交更新，所以尝试用下面的命令，将工作区该文件的修改丢弃，再拉取
git checkout -- package-lock.json

css vw的使用场景
在轮播图纯css的解决方案中：

将图片区域宽度设置为 图片张数 * 100%
hover切换按钮时，将图片区域向左移动一个100%：transform: translateX(100%)
这里就会有问题，向左移动100%，宽度是图片张数*100%，而不是视窗宽度，用 100vw就可以很好的解决了

在koa中，如果Content-Disposition里设置文件名有中文会提示错误，需要用类似 encodeURIComponent 转码的函数转码后才行

const fileName = encodeURIComponent('这是一个文件') // 需要先转码才行
ctx.set({
  'Content-Type': 'application/x-tar',
  'Content-Disposition': `attachment; filename="${fileName}.tar"`
})

浏览器tab页切换时更改标题
当用户点击了浏览器其他tab页离开页面，或者从其他tab页进入当前页，都会触发visibilitychange事件，根据docuemnt.hidden可以判断是否离开或回来，我们可以修改标题达到可视化的一个效果

// 实现tab间切换时，隐藏页面title改变功能
// JS高程3 Page Visibility API(页面可见性API)
// 参考：https://www.yuque.com/guoqzuo/js_es6/nocthb#0cf7a8b7
var title = document.title;
document.addEventListener('visibilitychange', function (event) {
  document.title =  document.hidden ? '~ 你快回来 ~ ' : title
  if (document.hidden) {
    // 做一些暂停操作
  } else {
    // 开始操作
  }
}, false)


页中网络异常或网络正常时动态提示
监听页面的online和offline事件，显示或隐藏对应的信息

// 当网络状态发生改变时（有网 => 无网，无网 => 有网）,提示信息
// JS高程3 离线检测
// 参考: https://www.yuque.com/guoqzuo/js_es6/sp2k81#244d3090
let errorMsgNode // 用来移除错误信息节点
window.ononline = function(event) {
  errorMsgNode && document.body.removeChild(errorMsgNode)
  message('success', '网络已连接', 3000)
}
window.onoffline = function(event) {
  message('error', '网络已断开')
}
/**
 * 为了显示网络信息，专门写了个小tips提示函数，在顶部显示信息
 * @param {}} type 文字颜色 error 为红色，其他为绿色
 * @param {*} msg 显示信息
 * @param {*} sec 如果有传入时间，sec秒后关闭提示
 */
function message(type, msg, sec) {
  let color = type === 'error' ? 'red' : 'green'
  let cssArr = [
    'position:fixed;top:8px;left:50%;z-index:9999999;',
    'transform:translateX(-50%);padding:5px 10px;background:#fff;'
  ]
  let htmlStr = `
    <div style="${cssArr.join('')}color:${color}">${msg}</di>
  `
  let node = document.createElement('div')
  node.innerHTML = htmlStr
  document.body.appendChild(node)
  if (Number.isInteger(sec) && sec > 0) {
    setTimeout(() => {
      document.body.removeChild(node)
    }, sec)
  } else {
    // 错误信息，一直提示，需要设置到变量里，等网络连接上时移除
    errorMsgNode = node
  }
}

页面滚动比例监听实现
监听页面的scroll事件，整个滚动距离为 document.documentElement.scrollHeight - window.innerHeight，当前scrollTop除以整个滚动距离，就是页面的百分比，向body挂载两个div来显示进度信息

// 页面滚动比例监听
// posTop 顶部类似阮一峰ES6网页的滚动进度条
// pos 右下角滚动百分比
// JS高程3 - UI事件 scroll事件
// https://www.yuque.com/guoqzuo/js_es6/elgng1#e38771e5
let htmlStr = `
  <div id="posTop" style="position: fixed;top:0;height:2px;background: #25b864;z-index:999999;"></div>
  <div id="pos" style="display:none;position:fixed;bottom: 100px;right:20px;padding:10px;background: #25b864;color:white;width:40px;text-align: center;border-radius:5px;"></div>
`
let eleNode = document.createElement('div')
eleNode.innerHTML = htmlStr
document.body.appendChild(eleNode)

window.addEventListener('scroll', function(e) {
  let scrollTop = document.documentElement.scrollTop;
  let total = document.documentElement.scrollHeight - window.innerHeight;
  let persentage = parseInt(scrollTop/total*100);
  // console.log(scrollTop);  

  document.getElementById('pos').style.display = scrollTop === 0 ? 'none' : 'block';
  document.getElementById('pos').innerHTML = `${persentage}%`;
  document.getElementById('posTop').style.width = `${persentage}%`;
}, false)

复制内容后，在内容中插入作者及当前文章信息
监听body里的copy事件，然后用 document.getSelection()获取内容，追加内容后，再使用event.clipboardData.setData像粘贴板里写入内容

// 操作粘贴板
// JS高程3 表单脚本 操作粘贴板
// https://www.yuque.com/guoqzuo/js_es6/ubpn7k#8482e7c5
document.body.oncopy = function(event) {
  console.log('copy', event);
  // 获取copy的内容
  // console.log(document.getSelection().toString());
  // 在copy内容里加入信息
  var msg = `
-----------------------------
标题：${document.title}
链接：${location.href}
作者：guoqzuo (http://github/zuoxiaobai)
  `
  event.clipboardData.setData('text/plain', `${document.getSelection().toString()} ${msg}`);
  event.preventDefault();
};

git删除远程分支与本地分支
删除远程仓库的分支，可以先查看当前所有分支

git branch -a # 查看当前分
# file_backup
# master
# remotes/origin/HEAD -> origin/master
# remotes/origin/file_backup
删除远程的file_backup分支
git push origin --delete file_backup
删除本地分支
git branch -d file_backup

css 利用 perspective 画梯形
今天看小伙伴的代码，发现有一个梯形的实现居然是css写的，我以为需要UI提供icon。这里用到了 perspective 远景这个参数

/*  <div class="tx"></div> */
.tx {
  width: 100px;
  height: 40px;
  margin: 100px;
  border: 1px solid #ccc;
  transform: perspective(2em) rotateX(-10deg);
}

git无法检测到文件名大小写的更改
今天把开发分支合并到月底分支后，发现之前修改过文件名没有提交上去，手动改文件名后，git status 提示没有任何改动。

于是百度了下，发现git默认配置为忽略大小写，因此无法正确检测大小写的更改。

解决办法在当前项目：git config core.ignorecase false，关闭git忽略大小写配置即可

JSON.stringify的非常规用法以及内部执行顺序
JSON.stringify我们一般用于将JSON对象转为字符串，但他不仅仅只有一个参数，而是三个，除最常用的用法外，还可以用来做三种实用功能

利用第三参数在console里更好的展示对象
// 1. 对于像这种多层级的数据，console到控制台时，会不好查看需要一层层点击，很麻烦
let obj = { list: [ {a: 1}, {a: 2}], total: 100 }
console.log(obj)

// 更好的展现，第三参数可以在转JSON字符串时，在json对象的缩进位置填充字符并加上换行符
// 缩进位置填充的内容，根据第三参数的类型决定：
// 如果是整数，填充对应的空格数(最大为10)，如果是字符串，填充充对应的字符串
JSON.stringify(obj, null, 2) 

有选择性的过滤字段
let obj = { list: [ {a: 1}, {a: 2} ], total: 100 }
// 如果我们想深拷贝obj，但只深拷贝其total字段，其他的字段不需要，就可以用第二个参数
let newObj = JSON.parse(JSON.stringify(obj, ['total']))
// newObj 值为 { total: 100 }

// 实例：在vue项目中，用js删除当前url query参数中的id参数
let query = this.$route.query
this.$router.replace({ 
  path: this.$route.path, 
  query: JSON.parse(JSON.stringify(query, Object.keys(query).filter(item => item !== 'id'))) 
})
详细处理没有字段序列化的值
let obj = { list: [ {a: 1}, {a: 2} ], total: 100 }
let new = JSON.stringify(obj, (key, value) => {
  return key === 'list' ? '改写list序列化的值' : value
}) 
// new 的值为 {"list":"改写list序列化的值","total":100}
JSON.stringify(obj)时，其实内部调用的是 obj 的 toJSON()方法，如果我们重写该方法，就可以改变序列化后返回的值

JSON.stringify()执行顺序

如果对象中存在toJSON方法，且能通过它获取有效的值，则调用该方法，返回对应的值用于下一步，否则返回对象本身。
如果提供了第二个参数，根据对应的参数过滤第(1)步得到的值
对第(2)步返回的每个值进行进行相应的序列化
如果提供了第三个参数，执行相应的格式化

Array.prototype.fill()填充引用类型值时的坑
在mock表格list数据时，我一般为了简洁会先创建一个对象info，然后new Array(10).fill(info) 来生成10条数据的数组

但这次发现一个问题，由于表格有一个字段是状态值0 - 5，我想随机设置下值，发现修改后的值都一样，来看看例子

let a = {a: 1}
let b = Object.assign({}, a) // {a: 1}
let c = Object.assign({}, a) // {a: 1}
b.b = 2 // 尝试修改值，看看a和c是否修改，发现只有b修改了，a,c没变说明地址不一样

// 来看看fill
let list = new Array(5).fill(Object.assign({}, a))
// 乍一看，貌似每个填充的地址都不一样，我们修改数组中的一个元素试试
list[0].b = 2
再打印list，发现list所有数组对象的值都变了，因此fill填充的对象都指向同一个地址

用 Array.prototype.fill() mdn查权威文档，发现里面确实有这一块的描述

// Objects by reference.
var arr = Array(3).fill({}) // [{}, {}, {}];
// 需要注意如果fill的参数为引用类型，会导致都执行都一个引用类型
// 如 arr[0] === arr[1] 为true
arr[0].hi = "hi"; // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]
那么遇到这种情况不能用fill要怎么处理呢

let a = {a: 1}
// 这里还是用了fill 如果不fill内容到数组，map遍历时会忽略所有空的元素
let list = new Array(5).fill({}).map(item => {
  item = Object.assign({}, a)
  item.xxx = Math.round(Matn.random() * 5)
  return item
})

Failed to resolve directive: infinite-scroll
在element InfiniteScroll无限滚动功能里，使用了v-infinite-scroll指令，但直接使用会发现提示 Failed to resolve directive: infinite-scroll，后面查了下，发现要使用该指令需要安装一个vue-infinite-scroll npm包，并且在main.js里引入才行

// 安装vue-infinite-scroll
// npm install vue-infinite-scroll --save

// 在main.js里引入
import infiniteScroll from "vue-infinite-scroll";
Vue.use(infiniteScroll);
这样就能正常使用了，注意加载数据 v-infinite-scroll="load" 指定的load函数里，获取数据后，每次push到列表list即可。首次进入会自动加载一次，无需在created钩子里手动请求一次数据，注意当在load里要加个判断，如果获取数据长度为0，或超出数据页数时，就不再继续load了

怎么将Date数据转为TZ格式的字符串
后台要求的数据格式 "2020-04-10T04:01:00.000Z" 为TZ格式的字符串。Date对象toString为 "Fri Apr 10 2020 12:00:00 GMT+0800 (中国标准时间)" 这种格式，那怎么转TZ字符串格式呢？用 Date.prototype.toJSON() 方法即可

a = new Date('2020/04/10 12:00:00') 
Fri Apr 10 2020 12:00:00 GMT+0800 (中国标准时间)

a.toJSON() //"2020-04-10T04:01:00.000Z"

Date.prototype.toLocaleString()的坑
注意在把Date转为字符串时，需要额外注意时间为 '00:00:00' 的情况，会被转为 上午12:00:00

a = new Date('2020/04/10 00:00:00') 
// Fri Apr 10 2020 00:00:00 GMT+0800 (中国标准时间)

a.toLocaleString() // "2020/4/10 上午12:00:00"
a.getHours() // 0
a.getMinutes() // 0
a.getSeconds() // 0
那我们来试试 '12:00:00' 的情况

a = new Date('2020/04/10 12:00:00') 
// Fri Apr 10 2020 12:00:00 GMT+0800 (中国标准时间)
a.toLocaleString() // "2020/4/10 下午12:00:00"
a.getHours() // 12
？？？怎么变下午12点了，综上虽然Date对象的toLocaleString()比较好用，但还是仅用日期方面的toLocaleDateString()吧，时间方面的还是尽量不要使用，12点和00点傻傻分不清楚

怎么用一行css代码将整个站点变灰
前天4月4号全国哀悼日，各大网公司网站的风格都变灰了，是怎么实现的呢？其实很简单，一行代码就搞定。

/* 将html下的所有内容置灰 grayscale为灰度 */
html {
  filter: grayscale(100%);
}
css filter是什么属性？用css filter mdn关键字查了下，这里filter翻译为 滤镜，他可以将模糊或色相等图形效果应用于元素，来看一些例子

/* 模糊，类似于马赛克效果 */
filter: blur(5px); 
/* 对比度 */
filter: contrast(100%);
/* 色相 */
filter: hue-rotate(90deg);
/* 阴影 */
filter: drop-shadow(16px 16px 20px red) invert(75%);

常用的.gitignore 配置
.DS_Store
node_modules
/dist

# local env files
.env.local
.env.*.local

# Log files
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw*

package-lock.json

canvas怎么绘制环形进度条
有4个重点:

怎么画圆弧, ctx.arc函数里开始角度、结束角度以PI为基准，取值范围时：0 ~ 2PI，PI就是π值约等于3.14，圆心正上方位置为1.5PI，圆心右侧为 0 或 2*PI，圆心正下方为0.5PI，选定义额开始位置和结束位置就可以绘制任意一个弧形，详情参见: 之前的canvas笔记 - 绘制路径(opens new window)

画圆环使用的是ctx.stroke，一般默认画圆大概是1px的宽度，线的宽度可以使用 ctx.lineWidth 调整，这样就成圆环了

用ctx.arc画一个完整的圆，再画一个进度圆弧，重叠在一起，颜色设置不一样，就是一个标准的圆环进度条了。

进度圆环怎么设置圆角，可以使用 ctx.lineCap = "round";

canvas_progress.png

<canvas id="drawing" width="180" height="180" >A draw of something.</canvas>
<script>
  let drawing = document.getElementById('drawing');
  let ctx = drawing.getContext('2d');
  let percent = 80 // 进度百分比
  let circleRadios = 80 // 圆环半径
  let lineWidth = 10
  let PI = 3.1415926
  let long  = (percent / 100) * PI * 2 // 百分比进度条长度
  let start = 1.5 * PI // 圆心正上方位置是 1.5PI
  ctx.lineWidth = lineWidth

  // 背景圆环
  let x = circleRadios + lineWidth
  let y = x
  ctx.beginPath()
  ctx.strokeStyle = 'rgb(241,247,255)'
  ctx.arc(x, y, circleRadios, start + long, start)
  ctx.stroke()

  // 进度圆环
  ctx.beginPath()
  let gradient = ctx.createLinearGradient(circleRadios * 2 + lineWidth * 2, lineWidth + circleRadios, 0 , circleRadios + lineWidth); // 从(130,130)到(160,160)渐变
  gradient.addColorStop(0, '#64E1FA'); // 渐变的起点色
  gradient.addColorStop(1, '#215BF7'); // 渐变的结束色
  ctx.strokeStyle = gradient
  ctx.arc(x, y, circleRadios, start, start + long)
  ctx.lineCap = "round";
  ctx.stroke()
</script>

a + 1 === a + 2 为true的情况
注意这里是全等，不是宽松相等时，隐式转换的问题。我现在了解的有两种情况：

// 1. Infinity
var a = Infinity // Infinity是这个神奇的数，我试了下除了 * 0等于NAN外，其他情况基本都等于他自己
a + 1 === a + 2 // true

// 2. Math.pow(2, 53) - 1 最大的安全整数
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) -1 // true
a = Number.MAX_SAFE_INTEGER
a + 1 === a + 2 // true
以上，当大于2的53次方-1时，就不安全了，结果会超出常规，ES2020引入了bigint来处理大于2的53次方-1的数据

// bigint类型的数与n结尾
a = BigInt(Number.MAX_SAFE_INTEGER) // 9007199254740991n
a + 1n // 9007199254740992n
a + 2n // 9007199254740993n

<style lang="less" scoped>
@import (reference) url('./common/base.less');
.container-mixin();
// 引入公共样式后，再修改部分公共的样式
.container {
  .top {
    background: red;
  }
}
</style>
上面的例子中使用 (reference) 是为了防止在不同的组件中引入导致公共代码多次打包问题

v-infinite-scroll 放到slot里或者用v-if控制时首次无法触发loadMore的问题
最新项目结构调整，发现一个问题，把 v-infinite-scroll 对应的元素放到 slot 里，首次无法触发loadMore, 不放到slot里面又是正常的，来看代码

<template>
  <div>
    <-- 用 sub-comps-middle 组件嵌套，写在slot时，无法加载loadMore，去掉sub-comps-middle 就是正常的-->
    <sub-comps-middle>
      <div v-infinite-scroll="loadMore" infinite-scroll-distance="10">
        测试
      </div>
    </sub-comps-middle>
  </div>
</template>
带着这个问题，我看了下 v-infinite-scroll 的源码，在关键位置写了几个console，找到了其中的原因，来看看产生问题的地方

// InfiniteScroll 部分源码
// github地址：https://github.com/ElemeFE/vue-infinite-scroll/blob/master/src/directive.js
var InfiniteScroll = {
  bind: function bind(el, binding, vnode) {
    el[ctx] = {
      el: el,
      vm: vnode.context,
      expression: binding.value
    };
    var args = arguments;
    console.log('bindfunc before mouted', el[ctx].vm, el[ctx])
    el[ctx].vm.$on('hook:mounted', function () {
      console.log('hook:mounted')
      el[ctx].vm.$nextTick(function () {
        if (isAttached(el)) {
          doBind.call(el[ctx], args);
        }
正常情况下，页面一加载，InfiniteScroll 会开始初始化，执行其bind函数。bind函数里加了一个监听，当接收到当前组件的 hook:mounted 事件，也就是mounted事件时，开始做真正的绑定，执行doBind方法。

那么问题来了，正常情况下，在组件mounted之前，InfiniteScroll会完成初始化，这样就可以接收到页面的mounted消息，然后执行真正的相关事件绑定。

假如我们把 v-infinite-scroll 写在slot里，当前页面组件mounted过后，InfiniteScroll才执行初始化，初始化时监听mounted再执行doBind，而页面已经mounted过了，所以会无法触发loadMore，同理，v-if 控制时，如果为false，可能会有InfiniteScroll没初始化之前，页面就已经mounted的情况。

怎么解决这个问题呢？记住 v-infinite-scroll 必须放在一个单独的单文件组件里，不要放到某个组件的slot里。且不要用v-if控制，使用v-show，这样就不会有问题了。

输入法组合文字事件compositionstart等不能用on监听
今天用原生的js来写demo时发现使用oncompositoinstart无法监听到输入法组合文件的过程，后面替换为addEventListener就可以了。因此对于输入法组合文字过程事件必须要使用DOM2级事件监听

<body>
  <input id="input"></input>
  <script>
    let input = document.querySelector('#input')
    console.log('input', input)
    let composition = false

    // input.addEventListener('compositionstart', (e) => {
    //   console.log('oncompositionstart')
    //   composition = true
    // });
    // input.addEventListener('compositionend', (e) => {
    //   console.log('oncompositionend')
    //   composition = false
    // });

    input.oncompositionstart = (e) => {
      console.log('oncompositionstart', composition)
      composition = true
    }

    input.oncompositionend = (e) => {
      console.log('oncompositionend', composition)
      composition = false
    }
  </script>
</body>
数组去重，去掉id重复的元素
有一个需求，客户信息列表，需要去除重复的客户。于是想着怎么写去重的逻辑，可以思考下

let customerList = [ 
  { id: '1', info: 'xxx' },
  { id: '3', info: 'xxx' },
  { id: '1', info: 'xxx' },
  { id: '2', info: 'xxx' },
  { id: '3', info: 'xxx' },
]

// 去重
let tempSet = new Set()
let newList = customerList.filter(item => {
  if (tempSet.has(item.id)) {
    return false
  }
  tempSet.add(item.id)
  return true
})
console.log(newList)
// [
//   { id: '1', info: 'xxx' },
//   { id: '3', info: 'xxx' },
//   { id: '2', info: 'xxx' },
// ]

axios取消请求，以及具体使用场景
以下是两个会用到取消当前请求的场景

tab切换刷新某个列表数据数据导致数据错乱的问题
导出文件或下载文件时，中途取消
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

// get 方法 假设这个接口需要50s才返回
axios.get('/user/12345', {
  cancelToken: source.token
}).catch(function (thrown) {
  if (axios.isCancel(thrown)) {
    console.log('Request canceled', thrown.message);
  } else {
    // handle error
  }
});

// post 方法时 假设这个接口需要50s才返回
// axios.post('/user/12345', {
//   name: 'new name'
// }, {
//   cancelToken: source.token
// })

// 3庙后取消请求
setTimeout(() => {
  // cancel the request (the message parameter is optional)
  source.cancel('Operation canceled by the user.');
}, 3000)

前端修改cookie后，相关cookie改动会传到后台吗
首先我们来捋一捋，什么是cookie？与cookie相关的知识点有两个：

前端获取/设置cookie，使用 document.cookie
HTTP请求与响应相关cookie
我们先下个结论：他们之间是相互关联的，接口响应头设置cookie，会对document.cookie的值产生影响；前端设置docuemnt.cookie也会对请求头cookie值产生影响，但如果后端写到前端的cookie如果使用了HttpOnly属性，前端是无法通过document.cookie做修改的

移动端rem自适应
设计图750 * xx(iphone 6/7/8 或 全面屏)，以100为基准

function initRem() {
  let html = document.documentElement
  let resizeEventName = 'orientationchange' in window ? 'orientationchange' : 'resize'
  let recalc = () => {
    let w = html.clientWidth < 320 ? 320 : html.clientWidth
    let fontSize = w > 750 ? 200 : ((w / 375) * 100)
    Object.assign(html.style, { fontSize })
  }
  recalc()
  [resizeEventName, 'DOMContentLoaded'].map(eventName => {
    document.addEventListener(eventName, recalc, false)
  })
}

vue实现一个tree组件
树形组件主要是递归的问题，组件自己调用自己，来写个简单的例子

<template>
  <div>
    <z-tree :data="treeData"></z-tree>
  </div>
</template>

<script>
export default {
  components: {
    ZTree: () => import("./ZTree")
  },
  data() {
    return {
      treeData: [
        {
          label: "冰箱"
        },
        {
          label: "水果",
          list: [
            { label: "苹果" },
            { label: "梨子" },
            { label: "葡萄" },
            {
              label: "喜欢的水果",
              list: [{ label: "水果1" }, { label: "水果2" }, { label: "水果3" }]
            },
            { label: "香蕉" }
          ]
        },
        {
          label: "茶叶",
          list: [
            { label: "铁观音" },
            { label: "西湖龙井" },
            { label: "毛尖" },
            {
              label: "红茶",
              list: [{ label: "红茶1" }, { label: "红茶2" }, { label: "红茶3" }]
            }
          ]
        }
      ]
    };
  }
};
</script>
ZTree.vue实现

<template>
  <!-- z-tree递归组件实现 -->
  <div>
    <ul>
      <li v-for="item in data" :key="item.label">
        {{ item.label }}
        <i class="iconfont el-icon-arrow-right" v-if="item.list"></i>
        <z-tree v-if="item.list" :data="item.list"></z-tree>
      </li>
    </ul>
  </div>
</template>

<script>
export default {
  components: {
    ZTree: () => import("./ZTree")
  },
  props: {
    data: {
      type: Array,
      required: true
    }
  },
  data() {
    return {};
  }
};
</script>
#select渲染上万条数据卡顿的问题
一般下拉选择时会使用select组件，但如果select数据过万，可能会产生卡顿，其实这种数据大的情况使用select就体验很差了。

可以做成弹窗选择或搜索框，那怎么保持select有数万条数据而不卡呢？我的理解是，使用触底刷新，滚动到底部时加载后面的内容

npm run 运行多条命令 && 不生效的问题
在项目中除了默认的 webpack-dev-server 外，我们还想同时运行mock接口的node服务

// npm run 同时执行下面的两条命令
// webpack-dev-server --config webpack.dev.js
// nodemon ./mock/index.js
一般 & 表示并列执行，&& 表示两条命令顺序执行。使用 && 的形式设置对应的script，如下

"scripts": {
  "server": "nodemon ./mock/index.js && webpack-dev-server --config webpack.dev.js"
}
但实际运行 npm run server 时，只运行了第一条命令，我的是mac，不知道是不是node版本的问题。网上找了下， && 存在兼容性问题。建议使用 concurrently 来代替，concurrently 跨平台兼容

// 先安装 concurrently
// npm install concurrently --save
// 修改 package.json 如下
"server": "concurrently \"nodemon ./mock/index.js\" \"webpack-dev-server --config webpack.dev.js\""
注意：&& 是按顺序执行多条命令， concurrently 是并列执行多条命令，对于跨平台的顺序执行，可以使用 npm-run-all

FileReader实例的readAsDataURL与createObjectURL区别
都是读取blob数据， FileReader实例的readAsDataURL下载文件会有限制，超过一定大小会出错，而window.URL.createObjectURL却没有限制

readAsDataURL URI base64数据 FileReader.readAsDataURL() | MDN(opens new window)

createObjectURL URL url URL.createObjectURL() | MDN(opens new window)

FileReader.readAsDataURL 读取文件之后是 base64 编码的字符串，这个是不能直接作为 src 使用的，要直接使用还应当拼接响应的 MIME Type 前缀，比如 data:audio/ogg; 这是 .ogg 格式的前缀，具体是什么前缀取决于你上传文件的扩展类型了。

其实这里没必要非使用 FileReader 来完成这个需求，读一些小的文件还可以，读大的文件其实不是很好。不如直接使用 URL.createObjectURL() 来创建一个 DOMString，然后直接使用这个 DOMString 即可，不过不要忘记使用完之后通过 URL.revokeObjectURL()方法来释放。

为什么会有回流/重排(Reflow)和重绘(Repaint)？怎么避免？
1. 什么是回流或重绘

浏览器使用流式布局模型 (Flow Based Layout)
浏览器把 HTML 解析成 DOM，把 CSS 解析为 CSDOM，DOM 和 CSDOM 合并就产生了 Render Tree(渲染树)
根据Render Tree，计算各个元素在页面中的大小和位置，绘制到页面上。
回流/重排（Reflow）：当 Render Tree 中部分或全部元素的尺寸、结构或位置发生改变时，浏览器会重新渲染部分或整个文档的过程就称为Reflow

重绘（RePaint）: 当页面中元素样式的改变并不影响它在文档中的位置时，浏览器会重绘该区域，这个过程称为重绘

2. 回流和重绘的比较

DOM、CSS style的改变会照成回流或者重绘，回流比重绘更消耗性能

回流：重新布局，会引起元素位置变化的就会reflow，比如修改 DOM 的宽高、字体大小、窗口大小改变、元素位置改变等
重绘：重新绘制区域，不改变元素位置，比如修改背景、颜色，visibility等
3. 如何避免回流或重绘

CSS：

尽可能在DOM树的最末端改变class
避免设置多层内联样式，将动画效果应用到 position 属性为 absolute 或 fixed 的元素上
避免使用CSS表达式（例如：calc())
JavaScript

避免频繁操作样式、DOM
在 documentFragment 或 display 为 none 的元素上进行 dom 操作不会引起回流或重绘
对复杂动画，使用绝对定位脱离文档流，避免整体回流

var docCookies = {
  getItem: function (sKey) {
    return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[-.+*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
  },
  setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
    if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
    var sExpires = "";
    if (vEnd) {
      switch (vEnd.constructor) {
        case Number:
          sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
          break;
        case String:
          sExpires = "; expires=" + vEnd;
          break;
        case Date:
          sExpires = "; expires=" + vEnd.toUTCString();
          break;
      }
    }
    document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
    return true;
  },
  removeItem: function (sKey, sPath, sDomain) {
    if (!sKey || !this.hasItem(sKey)) { return false; }
    document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + ( sDomain ? "; domain=" + sDomain : "") + ( sPath ? "; path=" + sPath : "");
    return true;
  },
  hasItem: function (sKey) {
    return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[-.+*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
  },
  keys: /* optional method: you can safely remove it! */ function () {
    var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
    for (var nIdx = 0; nIdx < aKeys.length; nIdx++) { aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); }
    return aKeys;
  }
};

图片占位、懒加载、预览
使用占位图片有什么好处?

用户体验更好，标识此处有图片，但正在加载中的这一个状态，避免弱网或图片较大时，完全不显示的问题
不阻塞其他资源加载，更快的整体文档加载速度，不阻塞其他请求。占位图片一般会和图片懒加载一起使用，当滚动到该区域时再加载图片，减少不必要的并发网络请求
可以避免回流，让图片加载完成后不改变页面的整体布局，避免回流(重新布局)，只需要重绘，注意: 需要占位图片与实际图片宽高不变
怎么实现图片懒加载

这里核心问题是怎么判断图片是否已滚动到当前视口。一般可以通过监听页面滚动事件，实时比较元素的 offsetTop 与页面的 scrollTop。另外还可以通过元素的 getBoundingClientRect() 获取当前元素距离视窗的距离，如果小于 window.innerHeight 就加载，下面来看一个简单的实现

<body>
  <div>
    <div style="height:50px;">我是占位文本</div>
    <img class="lazy-img" data-src="http://zuo11.com/images/blog/c/c_vim.png">
    <div style="height:500px;">我是占位文本</div>
    <img class="lazy-img" data-src="http://zuo11.com/images/blog/c/c_saolei_3.png">
  </div>
  <script>
    let imgEls = document.querySelectorAll('.lazy-img')
    let imgs = []
    imgEls.forEach(imgEl => {
      imgEl.style.height = '300px'
      imgEl.style.width = '300px'
      imgEl.src = "placeholder.png"
      // 存储信息用于监听滚动后比对
      imgs.push({
        offsetTop: imgEl.offsetTop,
        el: imgEl,
        src: imgEl.dataset.src,
        isLoad: false
      })
    })
    console.log(imgs)
    // 判断滚动位置，显示图片
    function showImg() {
      console.log('>>>>>>')
      imgs.forEach(item => {
        // 如果图片未加载
        if (!item.isLoad) {
          console.log(window.innerHeight, item.src, item.el.getBoundingClientRect())
          let elPos = item.el.getBoundingClientRect()
          if (elPos.top < window.innerHeight) {
            // 如果元素相对顶部的距离 < 视窗高度，加载图片
            item.el.src = item.src
            item.isLoad = true
          }
        }
      })
    }
    showImg()
    window.onscroll = () => {
      showImg()
    }
  </script>
</body>

QRCode.js是一个生成二维码的js库，使用 HTML5 Canvas将二维码绘制到dom上，不依赖任何库。支持svg绘制方式

QRCode.js is javascript library for making QRCode. QRCode.js supports Cross-browser with HTML5 Canvas and table tag in DOM. QRCode.js has no dependencies.

QRCode.js使用很简单，下面来写一个自动生成二维码的工具，在线示例 在线生成二维码工具(opens new window)

<body>
  <div style="margin-bottom:20px;">
    <input id="input" type="text">
    <button id="btn">生成二维码</button>
  </div>
  <div id="qrcode"></div>
  <!-- 在 https://github.com/davidshimjs/qrcodejs 下载的文件 --->
  <script src="./qrcode.min.js"></script>
  <script type="text/javascript">
    let inputEl = document.getElementById('input')
    let btnEl = document.getElementById('btn')
    btnEl.onclick = () => {
      document.getElementById("qrcode").innerHTML = ''
      // new QRCode(document.getElementById("qrcode"), inputEl.value);
      let qrcode = new QRCode(document.getElementById("qrcode"), {
        text: inputEl.value,
        width: 128,
        height: 128,
        colorDark: "#000000",
        colorLight: "#ffffff",
        correctLevel: QRCode.CorrectLevel.H
      });
      // 上面使用清空dom，再重绘，也可以使用内置的方法来重绘
      // qrcode.clear(); // clear the code.
      // qrcode.makeCode(inputEl.value); // make another code.
    }
  </script>
</body>
注意：如果输入的是纯文本，那扫描后打开的就是纯文本，如果是 http:// 开头的网址，会直接跳转到对应的 URL

keep-alive只在跳转到B组件页面时缓存当前路由数据，跳到其他页面不缓存路由数据
一般情况下，我们可以使用路由meta参数里传keepAlive为true或false来对某个路由页面做缓存

<keep-alive>
  <router-view v-if="$route.meta.keepAlive"></router-view>
</keep-alive>
<router-view v-if="!$route.meta.keepAlive"></router-view>
假设有A、B、C三个页面组件。B页面只有跳到C页面才缓存数据，跳到其他页面不缓存页面数据

这里 router-view 组件会切换三个组件的显示类似与component is切换组件。我们需要动态的去判断是否缓存B页面组件，可以使用keep-alive的include参数来指定需要缓存的页面组件数据

<!-- 逗号分隔字符串 -->
<keep-alive include="a,b">
  <component :is="view"></component>
</keep-alive>
假设B页面组件的name为 'PageB'，那么默认情况下include为'PageB'，就表示缓存该页面，如果设置include为''就是不缓存页面数据，核心问题是怎么动态的改变这个include的值。

我们可以在B页面组件路由离开之前的钩子函数里，来修改这个值，注意，需要单独弄一个变量，使用$route.meta.include参数来修改这个值是没有用的，因为$route.meta这个值并不像data里面的数据是双向绑定的，他在进入页面时就固定了。中间修这个值不会触发template里面的模板重新渲染

来看看具体实例

<!-- index.vue 入口页面 http://localhost:8081/keepAlive/ -->
<template>
  <div>
    我是主页面
    <ul>
      <li><router-link to="/keepAlive/a">A组件页面</router-link></li>
      <li><router-link to="/keepAlive/b">B组件页面</router-link></li>
      <li><router-link to="/keepAlive/c">C组件页面</router-link></li>
    </ul>
    include{{ include }}
    <keep-alive :include="include">
      <router-view v-if="$route.meta.keepAlive"></router-view>
    </keep-alive>
    <router-view v-if="!$route.meta.keepAlive"></router-view>
    <!-- 测试 $route.meta 的值是否是双向绑定的 -->
    $route.meta.include {{$route.meta.include}}
  </div>
</template>

<script>
export default {
  data() {
    return {
      include: "PageB"
    };
  },
  created() {
    // 这里修改值后数据，页面的$route.meta.include值并没有刷新，因此不能为了节省变量使用$route.meta来做include的控制
    setTimeout(() => {
      this.$route.meta.include = "test"
      console.log('this.$route.meta.include', 'test')
    }, 3000)
  }
};
</script>
/keepAlive/a、/keepAlive/c只是单独的页面，没有任何逻辑，只是用来测试跳转。主要逻辑是在/keepAlive/b页面

<template>
  <div>
    我是B组件页面
    <el-input v-model="input" placeholder="请输入B组件内容"></el-input>
    <el-radio-group v-model="radio">
      <el-radio :label="3">备选项</el-radio>
      <el-radio :label="6">备选项</el-radio>
      <el-radio :label="9">备选项</el-radio>
    </el-radio-group>
  </div>
</template>

<script>
export default {
  name: "PageB",
  data() {
    return {
      input: "",
      radio: ""
    };
  },
  beforeRouteLeave(to, from, next) {
    if (to.name === "keepAliveC") {
      // 如果跳转的页面C组件，缓存页面数据
      this.$parent.include = "PageB";
    } else {
      // 如果跳转的页面不是C组件，不缓存数据
      this.$parent.include = "";
    }
    next();
  }
};
</script>
以上就可以实现我们的目的了，完整demo参见 keepalive测试demo｜ github

.eslintignore文件的作用是，当不想对项目的某个目录进行eslint检查时，可以在这个文件中声明，类似.gitignore文件的效果。

// .eslintignore
mock

ue组件的封装性与可操作性：ref拿不到子组件实例以及vuex增加代码复杂度问题
一般在封装vue组件时，怎么把组件封装的更好，更容易维护理解是值得思考的问题

来看一个实际场景：一个组件里有高级查询和列表，他们东西都比较多，需要拆分成两个子组件

<!-- index.vue -->
<project-search></project-search>
<project-list></project-list>
查询的条件参数比较多，假设表单数据变量为 searchForm。

按照封装的完整性原则，自己的组件的数据放到自己的组件中，那么 searchForm 就需要放到 project-search 组件里。

但在index.vue中，我们需要查询列表，依赖searchForm的值，涉及到父组件取子组件的值的问题，一般有四种方法可以选择

searchForm变量放到父组件，通过props传递到子组件（这样有点违背组件的封装性）
vuex 个人认为，能不使用vuex的场景，尽量不要使用，除非真的需要使用，他会影响代码的简单性。
bus 使用 bus 来通信，但和vuex类似，尽量少使用
使用ref直接取。但由于副组件加载子组件时，在mounted钩子里 ref 拿对应的子组件可能会拿不到，需要加 setTiemout，也是一种比较怪的操作
对比这几种情况。我一般使用props，把值直接放到index.vue里，再传递给子组件。这样算是比较好理解的一种方法，虽然封装性不强。但涉及到数据需要交互的场景，必须要做一些妥协。

git status时，如果中问乱码，可以对git进行一个配置即可 git config --global core.quotepath false

外部链接 a 标签为什么要加 noreferer 与 noopener ？
一般页面的外部连接都会加上 ref="noreferer noopener"，这样可以避免一些安全问题，下面通过几个问题来具体看看

a 标签加上 noreferer 和 noopener 后会有什么效果？
Referer 是什么？
Referer 的应用场景
window.opener 可以做什么？
noreferer_1.png

a 标签加上 noreferer 和 noopener 后会有什么效果？

以 Github 上 less.js 仓库设置的网站链接为例，如上图。加了这两个参数后点击链接，该页面打开后

请求头（Request Headers）部分的 Referer 和直接访问的 Referer 一致，都为空，不会携带来源信息。
window.opener 和直接访问该网站一致，无法获取来源网站信息，无法操作来源网站的跳转等
请求头 Referer 是什么？

一般网页在加载html、js、css、图片等静态资源发送请求时，请求头部分会有一个 Referer 字段，用于标记请求来源。referer 单词存在拼写错误，本意是打算使用 referrer，写错了。后来为了兼容，将错就错，还是保留了错误的拼写方式。

Referer 的应用场景

Referer可以标记请求来源，有以下几个应用场景

用于统计分析，可以知道用户是从哪种方式进入网站的。搜索引擎一般不会开启 noreferer，比如百度统计可以知道你是通过哪个关键字进入的页面。

用于防盗链，防止网页静态资源被其他站点直接引用，如淘宝店铺图片、CDN图片链接、文件、视频链接等。一般会设置 referer 白名单，仅允许白名单内的 Referer 访问，否则禁止访问。减少服务器负载或不必要的 CDN 流量花费。

用于鉴权，比如页面在集成评论系统、Google AdSense等第三方功能时，会校验站点与ID是否匹配，如果不匹配会提示 403。防止其他网站引入对应的代码后，导致数据错乱。我们在处理接口请求时，也可以对 Referer 值进行判断，禁止某些来源访问接口。

window.opener 可以做什么？

window.opener 可以拿到来源网站的 window 对象，虽然一般访问 dom 等有跨域限制，但 window.opener.location 可以直接重定向网站，使来源站点发生变化，referer 保持源网站链接。使用 noopener 可以避免一些安全风险。

js使用localeCompare函数对中文进行首字母排序
tag: js中文按首字母排序, 前端中文按首字母排序,前端中文排序

String.prototype.localeCompare(compareString[, locales[, options]])

该方法用于对字符串进行排序。第二个参数 locales 可以指定语言，中文排序传 'ch' 即可。它的返回值为 -1, 1, 0 和 sort 自定义排序的返回值基本一致。来看一个例子

['中文zw', '啊啊啊aaa', '猜猜猜ccc'].sort((a, b) => a.localeCompare(b, 'ch'))
//  ["啊啊啊aaa", "猜猜猜ccc", "中文zw"]

console.log 打印带样式的文字，图片
console.log 的第一个参数中，如果有 '%c'，表示设置样式，会将第二个参数的 css 样式应用到第一个参数的内容中

console.log('%c文字', 'css样式')
这样可以打印绿色或红色的文字

console.log('%cSuccess!', 'color: green')

不仅可以设置文字颜色，还可以通过设置 background-color 在控制台显示图片

if (console) {
  console.clear();
  console.log("%c ", "padding:112px 150px;background:url('https://images.cnblogs.com/cnblogs_com/enumx/1647344/o_200214113324console.gif') no-repeat;");
  console.log('%cWelcome', 'color: #0000ff;font-size: 20px;font-weight: bold;');
}

lodash.js打包后默认是整包，怎么按需打包，减少包体积
在 vue-cli 打包 lib 项目时，发现包体积较大有 600多KB，于是使用 -- report 参数看具体是哪个包较大，发现尽管只用到了 lodash 的一个函数，但打包体积却有几百k，如下图，应该是整包打的，没有按需打包。

# 以 src/index.js 为入口，以库的形式打包到lib目录下，并生成 report.html
vue-cli-service build --mode lib --target lib --dest lib --report src/index.js
以下是 打开 lib/项目名.umd-report.html 后，显示的各模块大小示意图

这里借助 babel 的 loadsh 插件来进行按需打包。如果没有babel的配置文件，新建 .babelrc 文件，加入如下内容：

// .babelrc  使用 lodash 的babel插件
{
  "plugins": ["lodash"]
}
lodash 的 babel 插件就是 babel-plugin-lodash，需要先 npm 安装下

npm install babel-plugin-lodash -D
ok后，重新打包，就是按需打包了。如下图，体积只有 100 多 KB 了。

在来看看 report 信息，可以看到，只打包了使用到的函数

vue-cli build --target lib时如何避免打包成多个umd.js文件
vue-cli项目中，一般我们使用的是 npm run build 来构建项目，并发布到线上。当我们写组件/工具库的时候，就需要使用 --target lib 参数了。

打包成库与普通的构建应用不一样，它会在 dist目录下生成对应的 umd.js 文件，也就是通用模块定义的 js 文件。一般用于组件/工具库的入口文件，我们可以在静态 html 以及 vue-cli 等项目中直接引入并使用。如果不进行构建，只能在 vue-cli 项目中使用，无法引入一个 js 直接使用。

在项目中，运行打包命令

# 打包成库 Library，指定入口为 src/index.js，构建后生成目录为 lib 目录
# --mode lib 不单独生成css，样式内联
# --target lib 打包形式为 lib
vue-cli-service build --mode lib --target lib --dest lib src/index.js
执行效果如下

一般我们把 *.umd.js 引入到项目中就可以使用。但这里分包了。将 *.umd.js 文件，分了好几个小包。在普通 html 文件里面引入是可以正常运行的。他会根据 umd.js 找到需要加载的其他分包并加载。但在vue项目中只引入 *.umd.js，其他分包不会打包到项目中，导致无法运行。

其实看上面的图，js 文件超过 77KB 左右就分块了。Gzipped 压缩后不到 12KB，我们完全可以将这些打包成一个 umd.js 文件，而不需要分多个文件。

这里借助 webpack 的一个插件来配置 Chunk 数量，maxChunks 设置为 1，只打一个包，不分多个 js 文件。在 vue.config.js 里修改webpack 的配置。

// vue.config.js
const webpack = require("webpack");
module.exports = {
  configureWebpack: {
    plugins: [
      // 限制只打一个包，不分Chunk
      new webpack.optimize.LimitChunkCountPlugin({
        maxChunks: 1
      })
    ],
    // 当库里面引入了比较大的文件时，为了不影响主包大小，需要设置下该包使用外部引入
    externals: {
      echarts: "echarts"
    }
  }
};
这样设置后，再重新打包就正常了，只有一个包，各平台就都没问题了。而且 gzip 压缩后也才 14KB 不到。如下图

扩展：

如果想要了解对于 vue-cli 打包 vue-cli-service --target lib 的具体执行，可以看 Vue CLI 源码

// @vue/cli-service/lib/commands/build/index.js
// Vue CLI源码，bulid 入口文件，lib时，配置处理
// resolve raw webpack config
let webpackConfig
if (args.target === 'lib') {
  webpackConfig = require('./resolveLibConfig')(api, args, options)
} 
// .....
else {
  webpackConfig = require('./resolveAppConfig')(api, args, options)
}

// @vue/cli-service/lib/commands/build/resolveLibConfig.js
// Vue CLI源码，lib 时 输入、输出文件配置
rawConfig.output = Object.assign({
  library: libName,
  libraryExport: isVueEntry ? 'default' : undefined,
  libraryTarget: format,
  // preserve UDM header from webpack 3 until webpack provides either
  // libraryTarget: 'esm' or target: 'universal'
  // https://github.com/webpack/webpack/issues/6522
  // https://github.com/webpack/webpack/issues/6525
  globalObject: `(typeof self !== 'undefined' ? self : this)`
}, rawConfig.output, {
  filename: `${entryName}.js`,
  chunkFilename: `${entryName}.[name].js`,
  // use dynamic publicPath so this can be deployed anywhere
  // the actual path will be determined at runtime by checking
  // document.currentScript.src.
  publicPath: ''
})

Google广告一个页面怎么显示多个广告，多个广告只显示的一个是什么原因？
在 Google Adsense 中，理论上配置好广告形式后，获取代码，把对应的代码放到页面中就可以显示广告了。但发现，如果放多个广告，只有一个可以显示出来，下面来看看是为什么？

官方提供的代码如下:

<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js'></script>
<ins class='adsbygoogle'
     style='display:block'
     data-ad-client='ca-pub-9527676606416000'
     data-ad-slot='3653238000'
     data-ad-format='auto'
     data-full-width-responsive='true'></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
一般在验证开通 Google Adsense 时，就会引入第一行 script 代码。那么只需要把下面的 ins 元素 和 script 里的代码拷贝进页面里就行。

当有多个广告时，我只拷贝了 多个 ins 到指定位置。 script 里面 (adsbygoogle = window.adsbygoogle || []).push({}); 只放到了 body最后面的 script 里，这时只能显示一个广告。于是我看了下其他可以显示多个 google 广告的页面，打开源码后，发现最下面的 script 里的内容也要多次拷贝。也就是 如果页面上要放多个 google 广告，每次都需要引入 ins + script 两部分的代码

<!-- 广告 1 -->
<ins class='adsbygoogle' style="ins内容简写"></ins>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>

<!-- 广告 2 -->
<ins class='adsbygoogle' style="ins内容简写"></ins>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>

DOMContentLoaded与Load时间具体指的是什么时间？
在 Chrome DevTools 官网 Network Reference (opens new window)里是这样介绍的：

View load events

来看看 DOMContentLoaded 和 load 事件在 MDN 的解释

DOMContentLoaded事件：window 和 document 上都可以监听，意思一致

window.addEventListener('DOMContentLoaded', (event) => {
  console.log('DOM fully loaded and parsed');
});
document.addEventListener('DOMContentLoaded', (event) => {
  console.log('DOM fully loaded and parsed');
});

DOMContentLoaded 事件：当 DOM (HTML document) 完成加载并解析，而不用等 css样式、图片和子 frame 完全加载完成时触发

同步 JS 会使 DOM 的解析暂停，如果希望用户在请求页面后尽快解析DOM，你可以把 JS 使用异步加载，并优化 css 样式加载方式。如果按照惯例加载，样式表和 JS 是并行加载的，会减慢 DOM 解析，窃取主html文档解析速度。下面是 head 中 script 默认加载以及加上 async, defer 参数的对比，一般把 script 放到 body 末尾，基本等价于 header 中 defer 的效果

load事件：window

window.addEventListener('load', (event) => {
  console.log('page is fully loaded');
});
// 或
window.onload = (event) => {
  console.log('page is fully loaded');
};

当整个页面加载完成时（包括所有相关资源，例如css样式表和图片），这与 DOMContentLoaded 相反，它在页面DOM被加载后立即触发，而无需等待资源完成加载。

DOMContentLoaded与Load时间具体指的是什么时间？
在 Chrome DevTools 官网 Network Reference (opens new window)里是这样介绍的：

chrome_load_events.png

View load events

DevTools displays the timing of the DOMContentLoaded and load events in multiple places on the Network panel. The DOMContentLoaded event is colored blue, and the load event is red.

来看看 DOMContentLoaded 和 load 事件在 MDN 的解释

DOMContentLoaded事件：window 和 document 上都可以监听，意思一致

window.addEventListener('DOMContentLoaded', (event) => {
  console.log('DOM fully loaded and parsed');
});
document.addEventListener('DOMContentLoaded', (event) => {
  console.log('DOM fully loaded and parsed');
});
The DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.

DOMContentLoaded 事件：当 DOM (HTML document) 完成加载并解析，而不用等 css样式、图片和子 frame 完全加载完成时触发

同步 JS 会使 DOM 的解析暂停，如果希望用户在请求页面后尽快解析DOM，你可以把 JS 使用异步加载，并优化 css 样式加载方式。如果按照惯例加载，样式表和 JS 是并行加载的，会减慢 DOM 解析，窃取主html文档解析速度。下面是 head 中 script 默认加载以及加上 async, defer 参数的对比，一般把 script 放到 body 末尾，基本等价于 header 中 defer 的效果

load事件：window

window.addEventListener('load', (event) => {
  console.log('page is fully loaded');
});
// 或
window.onload = (event) => {
  console.log('page is fully loaded');
};


当整个页面加载完成时（包括所有相关资源，例如css样式表和图片），这与 DOMContentLoaded 相反，它在页面DOM被加载后立即触发，而无需等待资源完成加载。

#vue项目页面打开时间优化：从16秒到2秒内
Tag: vue-cli项目页面加载时间太长、npm run build 打包很大、vue vendor.js文件太大

在日常开发中，经常要写一些 demo 来测试一些功能，我专门弄了个 github 仓库来管理，方便沉淀积累。这次想着把 vue demo 部署到服务器，方便PC/手机实时看效果。于是把 vue-cli 项目 npm run build 后，将 dist 部署到服务器 nginx 下，但发现打开很慢，下面来看看

如下图，DOM加载完 15秒，完全加载 16秒

主要是 chunk-vendors.js 接近 1.7M，下载时间较长。npm run build 打包后 log 如下图(这是后面补的图，中间把路由懒加载改了下，size 会比上图里的小一点)，超出建议的 244kB

理论上，nginx 开启 gzip 成功后，文件大小应该是 600多kb，看最上面的 Chrome Network 图里面，vendors 是 1.7M，且 Content-Encoding 那一栏没有 gzip，说明 js,css文件没有开启 gzip 咱们配置下 nginx 服务，开启 gzip

server
{
  server_name www.zuoguoqing.com;

  # 开启gzip
  gzip on;
  gzip_vary on;
  gzip_min_length 1000;
  gzip_comp_level 2;
  gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml image/jpeg image/gif image/png application/javascript; 
  
  location / {
    # root   html;
    # index  index.html index.htm;
    proxy_pass http://127.0.0.1:3000;
  }
}
咱们再来看看效果，如下图。vendors.js 文件从 1.7M 变为 600多k，且 Content-Type 那一栏也有了 gzip 标识。

下图可以看出 nginx 开启 gzip 压缩后，加载时间快了 5s。注意网上说的 compresion-webpack-plugin 插件在前端进行 gzip 在我看来基本是多此一举。nginx本身可以配置 gzip 功能，前端不用做 gzip 处理

11秒还是有点长，咱们想办法来减少 vendor.js 的体积看看，上面的图里面，gzip压缩后的 venders.js 有 613KB，加载也要 7秒多。

这里我们要使用 vue-cli(@vue/cli) 自带的 webpack 包体积优化工具，它可以查看各个模块的 size 大小，方便优化。只需要在 build 后面加上 --report 参数即可。我们把命令配置到 package.json 里，方便 npm run report 打包并生成 report，注意：网上很多说要先安装 webpack-bundle-analyzer 包，但不装也可以。

// package.json
"scripts": {
  "serve": "vue-cli-service serve",
  "build": "vue-cli-service build",
  // 加入下面一行
  "report": "vue-cli-service build --report"
},
根据上面的配置后，运行 npm run report 后，会在 build 的同时，在 dist 目录会生成一个 report.html，打开后如下图，我们可以看到 ElementUI 和 Echarts 占用较大，直接打包了 node_modules 里面框架的内容。

这里我们可以把 Echarts 改为外部引用 cdn，不打包到主包 vendors.js 里，另外再把 Element改为懒加载，只加载使用到的部分模块

如果只把 Echarts 改为外部引入，ElementUI 整体引入，大概还有 1.4M 左右。Element 按需加载后就锐减了，提示大小就变为 596KB 了，如下图

对应的 report.html 图如下，可以看到

看完效果后，下面来看方法，怎么把 Echarts 外部引用，以及 Element 怎么按需加载。外部引入需要配置两个地方：

在 vue.config.js的configureWebpack.externals加入需要外部使用的包
在 public/index.html 里引入对应的包
下面是 Echarts 外部引用需要配置的地方

// vue.config.js 
module.exports = {
  configureWebpack: {
    externals: {
      echarts: "echarts",
    }
  }
};
<!-- public/index.html -->
<!-- 写在 head 最下面或 body 最下面 -->
<!-- echarts cdn -->
<script src="https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts-en.common.min.js"></script>
再来看看 Element 按需引入。注意 Element 按需引入，也需要两步

修改 main.js 里的 Element 引入方式，单个模块逐一引入
按需引入，依赖的是 babel-plugin-component，vue-cli 项目已经带了对应的功能，在 babel.config.js 加入配置即可(官网提示是在 .babelrc ，如果vue-cli 项目,有了 babel.config.js 就在该文件配置)。 参考: 按需引入 | ElementUI(opens new window)
// main.js 
// Element 完整引入
// import ElementUI from "element-ui";
// Vue.use(ElementUI);
// Element 按需引入
import {
  Input,
  Button,
  // ...
} from "element-ui";
import "element-ui/lib/theme-chalk/index.css";
Vue.use(Input);
Vue.use(Button);
// ...
// babel.config.js
module.exports = {
  presets: ["@vue/cli-plugin-babel/preset"]
  // element 按需引入
  plugins: [
    [
      "component",
      {
        libraryName: "element-ui",
        styleLibraryName: "theme-chalk"
      }
    ]
  ]
};

这样设置后，从原来的 1.8M 优化到了 596KB，再来看看加载时间，如下图。只需要 3.6s 了，整整快了 7~8s

如上图所示，echarts 外部引入的js使用了 cdn，且开启了 gzip，只有 168KB，加载时间仅 65ms，而我的 vendors.js gzip压缩后只有 122KB，下载时间较长，加载用了 2.23s，我部署的服务器是入门级的较慢，还是 cdn 快。另外 vendors.css 里面有 Element 的 css 文件，咱们也换成外部引入 cdn 试试

修改 main.js，不按需引入 Element。把 Element 的 css 也放到外部引入

// main.js
import ElementUI from "element-ui";
Vue.use(ElementUI);
// import "element-ui/lib/theme-chalk/index.css";
修改 vue.config.js，设置 vue、ElementUI 外部引用

module.exports = {
  configureWebpack: {
    externals: {
      // 需要使用外部引入的包名：包名
      echarts: "echarts", 
      vue: "Vue", // 注意 vue需要外部引入。放到 echarts前面，防止 console 报错
      // element: "ElementUI" 可以打包成功，但chunk-vendors.js里面会打包element
      "element-ui": "ELEMENT"
    }
  }
};
去掉 babel.config.js 里面 Element 按需引入代码，修改 public/index.html，直接head里面引入

<!-- pbulic/index.html -->
<head>
  <!-- 引入Element css -->
  <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
  <!-- echarts -->
  <script src="https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts-en.common.min.js"></script>
  <!-- 引入vue -->
  <script src="https://cdn.jsdelivr.net/npm/vue"></script>
  <!-- 引入Element js -->
  <script src="https://unpkg.com/element-ui/lib/index.js"></script>
<head>
把 Element 和 vue 都改为外部引入后，再来看看，如下图，完全没警告了，低于 244KB，vendors.js 只有 68 KB

对应的 report.html 图如下，其实吧 vue-router、vuex 也使用 cdn 可能 vendor 会更小，但感觉不是很必要了。vendors.js 已经很小了

再来看看加载时间，还是要 3s 多 ？？？ 可以明显的看到 index.css 是 ElementUI 的 css，这个官方推荐的 unpkg cdn 有点慢，不是 gzip的压缩，是 br 的压缩方式。 32.7k 要 1.33s。（下图里面是 2.5s，其实整体是 3s 多，ElementUI的 JS 我已经换为了 bootcdn。之前的图压缩时不小心被覆盖了。）

这里我们再把 Element css 也替换为 bootcdn 连接，连接如下

<link href="https://cdn.bootcdn.net/ajax/libs/element-ui/2.9.2/theme-chalk/index.css" rel="stylesheet">
<script src="https://cdn.bootcdn.net/ajax/libs/element-ui/2.9.2/index.js"></script>
替换后再来看看效果，整体 loaded 只要 1.89s 了。

上面的图，是取的均值。再次刷新可能会低于 1s，也可能会高于。我这里在测试时都勾选了 Disable cache。就是不使用缓存，有时候可能 dns 解析，https 验证时间、服务器响应时间会有差别。

#vue Cannot read property 'prototype' of undefined
由于 vue 项目 npm run build 打包时 ElementUI 体积较大，因此把他单独抽离出去。放到 public/index.html 里直接引入。但抽离出去后发现启动后控制台会报这样一个错误：Cannot read property 'prototype' of undefined。

网上查了下，是在 public/index.html 里引入 Element JS script 的前面，没有加入 Vue.js 的引入照成的。这里我们加入 Vue.js 的引入即可。

<!-- public/index.html -->
<!-- 引入element组件js前加入vue的引入 -->
<script src="https://cdn.jsdelivr.net/npm/vue"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/element-ui/2.9.2/index.js"></script>
在 vue.config.js 里设置 ElementUI以及JS使用外部引入

module.exports = {
  configureWebpack: {
    externals: {
      // 需要使用外部引入的包名：包名
      vue: "Vue",
      "element-ui": "ELEMENT"
    }
  }
};
#vue.config.js: "plugins" is not allowed
在vue.config.js中，webpack 相关的配置需要写到 configureWebpack 里，不能直接写到外面

// vue.config.js
module.exports = {
  plugins: [], // error，"plugins" is not allowed
  configureWebpack: {
    plugins: [],
    externals: {}
  }
};

vue中文本@功能实现
如果自己写一个@功能会比较麻烦，在 github 上找了一个现成的开源库：Tribute (opens new window)- ES6 Native @mentions，它是ES 原生的实现，社区有各种框架的实现。这里我们使用它的 vue 实现 vue-tribute (opens new window)。下图是实现效果

在线示例：https://www.zuoguoqing.com/at 对应的 vue 代码如下，需要注意的地方

我们引入 vue-tribute 组件，传入 options 即可
样式方面，需要写弹出选择框的样式，不然就没有样式
options 的配置完全是 Tribute 的配置，到对应的 github 上查找即可，options的可选值支持动态渲染，支持从接口取
<template>
  <div class="container">
    <h3>contenteditable @mentions</h3>
    <vue-tribute :options="options">
      <div
        class="content-editable"
        contenteditable="true"
        @input="valueChange"
        placeholder="@..."
      ></div>
    </vue-tribute>
    <br />
    <div>
      <p>纯文本textContent：</p>
      <p>{{ textContent }}</p>
    </div>
    <div>
      <p>富文本innerHTML：</p>
      <p>{{ innerHTML }}</p>
    </div>
  </div>
</template>
<script>
import VueTribute from "vue-tribute";
export default {
  components: {
    VueTribute
  },
  computed: {},
  data() {
    return {
      textContent: "",
      innerHTML: "",
      options: {
        trigger: "@",
        // specify whether a space is required before the trigger string
        requireLeadingSpace: false,
        noMatchTemplate: "<li>暂无数据</li>",
        values: [
          { key: "张三 zhangsan", value: "张三" },
          { key: "李四 lisi", value: "李四" },
          { key: "王五 wangwu", value: "王五" },
          { key: "周杰伦 zhoujielun", value: "周杰伦" }
        ],
        positionMenu: true,
        selectTemplate: function(item) {
          return (
            '<span contenteditable="false"><a>' +
            "@" +
            item.original.value +
            "</a></span>"
          );
        }
      }
    };
  },
  methods: {
    noMatchFound() {
      console.log("暂无数据");
    },
    valueChange(e) {
      console.log(e.target.innerHTML, e.target.textContent);
      this.textContent = e.target.textContent;
      this.innerHTML = e.target.innerHTML;
    }
  }
};
</script>
<style lang="less">
// Tribute-specific styles 略
</style>

HTTP/2，怎么确定网站是否开启了HTTP/2，HTTP/3？
HTTP/2是新一代的HTTP协议，于2015正式发布。相对 HTTP/1来说，大幅提升了网页性能，绝大多数浏览器都支持了HTTP/2。

http怎么开启http2呢？HTTP/2 现阶段必须使用https，80端口就不要想了。参考: 拥抱HTTP2.0时代，让网站飞起来 | 百度站长(opens new window)

HTTP/1.1 的缺陷

连接无法复用，每次请求都经历三次握手和慢启动
HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。
HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。
队头阻塞(Head-Of-Line Blocking,HOLB)，并发请求数量限制
当页面中需要请求很多资源的时候，HOLB（队头阻塞）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。
HTTP 1.0：下个请求必须在前一个请求返回后才能发出，request-response对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。
HTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，pipeling 只部分解决了 HOLB。
协议开销大，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。
安全因素，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性
HTTP/2 就是为了解决 HTTP/1 存在的问题而产生的

二进制传输，HTTP/1.1传输的是文本数据，而HTTP/2传输的是二进制数据，提高了数据传输效率。
多路复用，多个HTTP请求可以复用同一个TCP连接。解决了浏览器限制同一个域名下的请求数量的问题，减少额外的3次握手开销。
压缩请求头(Header)，减少重复发送相同的请求头
支持服务器推送(Server push)，允许在请求之前先响应数据到客户端（之前请求过的数据），可以加快css/js等资源加载速度
开启 HTTP/2 只需要在 listen 443 ssl 后面加上 http2 即可，可以使用 curl -I 进行测试看HTTP/2是否生效

# /etc/nginx/conf.d/docker.conf 
server
{
    server_name www.zuoguoqing.com;

    location / {
      proxy_pass http://127.0.0.1:3000;
    }

    listen 443 ssl http2; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/www.zuoguoqing.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/www.zuoguoqing.com/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
}
来看看 HTTP/1.1 和 HTTP/2 的测试对比

curl -I www.zuo11.com
# HTTP/1.1 200 OK
# Server: nginx/1.16.1
# Date: Thu, 08 Oct 2020 09:08:55 GMT
# Content-Type: text/html; charset=utf-8
# Content-Length: 3666
# Last-Modified: Thu, 01 Oct 2020 15:02:42 GMT
# Connection: keep-alive
# Vary: Accept-Encoding
# ETag: "5f75ef92-e52"
# Accept-Ranges: bytes

curl -I https://www.zuoguoqing.com
# HTTP/2 200 
# server: nginx/1.14.0 (Ubuntu)
# date: Thu, 08 Oct 2020 09:09:07 GMT
# content-type: text/html
# content-length: 213
# last-modified: Wed, 07 Oct 2020 09:03:03 GMT
# etag: "5f7d8447-d5"
# accept-ranges: bytes
HTTP/2够好了，为什么还会有 HTTP/3？

HTTP/2 的问题在于，其底层支撑协议为 TCP，在丢包的情况下，多个请求复用一个 TCP 连接时，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。这时 HTTP/2 效果可能还不如 HTTP/1

因此，Google 又弄了一个基于 UDP 协议的 QUIC 协议，是 HTTP/3中的底层支撑协议，又取了 TCP 中的精华，实现了即快又可靠的协议。

通过提高链接利用效率减少 RTT（Round Trip Time，通俗地说，就是通信一来一回的时间），提高数据交互速度。
在第一条的基础上，囊括安全需求。
解决当前实际网络环境中的适配问题

字符串原始类型不是对象，为什么可以使用点语法运行方法
理论上，原始值本身不是对象，逻辑上是不能有属性、方法的。下面的例子中，第 2 行可以正常执行。主要是 JS 内部在后台进行了一些处理

let s1 = "some text"
let s2 = s1.substring(2) // "me text"
在执行到第 2 行时

临时创建一个 String 类型的实例 let t = new String("some text")
调用实例上的特定方法 s2 = t.substring(2)
销毁实例 t = null
这种行为可以让原始值拥有对象的行为。临时创建的 原始值包装类型（String）实例的声明周期只在执行的那一行。执行完后，就销毁了。下面的例子即可说明这个问题。

let s1 = "some text"
s1.color = "red"
console.log(s1.color) // undefined

使用 hash 滚动页面时，被顶部 fix 区域遮挡怎么解决
一般页面 URL 的 hash 值变化后，如果当前页面中存在 id 为该 hash 值的元素，页面会滚动到该区域。下面的例子中，点击跳转到h1，页面会滚动到 h1 元素，元素对齐到顶部。这里有一个问题，如果顶部导航栏是 fixed 固定的，那使用这种方法滚动时，h1 标题会被导航栏遮挡。

<h1 id="h1">一级标题</h1>
<a href="#h2">跳转到h2</a>
// 假设这里有很长的内容，超过一页
<h2 id="h2">二级标题</h2>
<a href="#h1">跳转到h1</a>
之前在写 zuo-blog 时，我的决绝方案是：滚动到顶部后，再往下滚动 70 px，这种方法有一个缺点，就是只能是 JS 跳转，如果直接通过 a 标签访问，还是会被遮挡

document.getElementById(id).scrollIntoView(true)
document.documentElement.scrollBy(0, -70)
后来使用 VuePress 时，发现跳转的时候没有遮挡，于是审查元素，看了下样式。发现使用一个 css 就可以解决这个问题。 给需要定位到该 id 的元素加一个超过导航栏高度的 padding-top，再加一个保持元素位置的 margin-top，这样使用 hash 滚动到该 id 元素时，就不会有遮挡，会与顶部保持 padding 的距离

h1,h2,h3,h4,h5,h6 {
  margin-top: -3.1rem;
  padding-top: 4.6rem;
  margin-bottom: 0;
}

getElementsByTagName 为什么不可以 forEach ？和 querySelectorAll 有什么区别
在 JS DOM 编程艺术的例子中，看到 getElementsByTagName 后使用了 Array.from(xx) 将其结果转为标准数组后再使用 forEach。 下面写个例子来验证为什么？
 <nav>
  <ul>
    <li><a href="index.html">Home</a></li>
    <li><a href="about.html">About</a></li>
  </ul>
</nav>
<script>
  let nav = document.getElementsByTagName('nav')[0]
  let linkArr = nav.getElementsByTagName('a')
  console.log(linkArr) // HTMLCollection [] => Object
  console.log(linkArr[0].__proto__)  // HTMLAnchorElement
  // HTMLAnchorElement => HTMLElement => Element => Node => EventTarget => Object
  // <nav> HTMLElement
  // <li> HTMLLIElement 
  console.log(linkArr[0].nodeType, linkArr[0].nodeName) // 1 "A"
  console.log(linkArr.__proto__) // HTMLCollection [] 

  // Uncaught TypeError: linkArr.forEach is not a function
  linkArr.forEach(item => console.log(item))
</script>
getElementsByTagName返回结果类型

从上面的例子中，我们可以看到 getElementsByTagName 函数返回的数据类型是 HTMLCollection，它是直接使用 Object 创建的对象，并没有实现 forEach 方法，但它内部实现了遍历、for...of（Symbol.iterator）方法，因此可以使用 for、for...of 来遍历

我们换个思路，使用 Array.prototype.forEach.call 来调用试试

// forEach 基本用法
[1,2,3].forEach((item, index, array) => console.log(item, index, array))

// 使用 prototype.forEach 直接运行
let cb = (item, index, array) => console.log(item, index, array)
Array.prototype.forEach.call(linkArr, cb)
可以正常执行，执行结果如下图。因此 Array 下的一些方法，我们可以使用 prototype 方式使用

querySelectorAll返回结果类型

同样是获取元素列表，querySelectorAll 返回的结果类型是 NodeList

// 和 querySelectorAll 对比
let linkArr2 = document.querySelectorAll('li a')
console.log(linkArr2) // NodeList [] => Object
console.log(linkArr2[0].__proto__)  //  HTMLAnchorElement
console.log(linkArr2[0].nodeType, linkArr2[0].nodeName) // 1
console.log(linkArr2.__proto__) // NodeList [] 
linkArr2.forEach(item => console.log(item))
如下图，NodeList 类型实现了 forEach, for...of 等方法，所以可以直接使用 forEach 遍历

综上：getElementsByTagName 返回的结果为 HTMLCollection 类型，而 querySelectorAll 返回的结果为 NodeList。HTMLCollection 并没有实现 forEach，无法使用点语法执行forEach，而 NodeList 是可以的。

S数据类型有多少种，有哪些细节需要注意的？
ES3 有 5 种基本数据类型，1种复杂数据类型。ES6+ 后面新增了两种基本数据类型：Symbol, bigint

注意：

typeof 函数值为 function, typeof null 值为 object，本质上其实有 9 种数据类型。
new String('12') 是字符串对象，不是 string，new Number(1) 是数字对象，不是 number，new Boolean(false) 是对象，不是 boolean
新增的 Symbol 以及 bigint 都是不能 new 的，没有 constructor 构造函数方法
var a = null,       // null
    b = undefined, // undefined 
    c = false, // bollean
    d = 1, // mumber
    e = "123", // string
    f = {}, // object
    g = Symbol("3"), // symbol
    h = BigInt(4); // 4n bigint
[a, b, c, d, e, f, g, h].forEach(item => console.log(`typeof `, item, `: ${typeof item}`))
// typeof  null : object
// typeof  undefined : undefined
// typeof  false : boolean
// typeof  1 : number
// typeof  123 : string
// typeof  {} : object
// typeof  Symbol(3) : symbol
// typeof  4n : bigint

设置允许跨域的响应头后，为什么还是不能跨域
在 post 请求中，明明设置了允许跨域的响应头，且考虑了 preflight 预检请求，但为什么还是报不能跨域的错误呢？下面来看看下面的例子，POST 请求中设置了允许跨域、允许预检的响应头

router.post('/corsTest', ctx => {
  // 以及允许跨域了
  ctx.set({
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': '*',
    'Access-Control-Allow-Headers': '*'
  })
  ctx.body = { a: 123 }
})
我们需要深入了解预检请求的过程，预检请求会先发送一个 OPTIONS 的请求去测试服务端是否允许跨域。这个时候我们需要注意，我们也需要处理对应接口的 OPTIONS 请求，上面只处理了接口 URL 的 POST 请求，并没有处理 OPTIONS 请求，可以使用 router.use(url, func) 或者加一个 router.options 请求处理

// options 预检请求时允许
router.options('/corsTest', ctx => {
  ctx.set({
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': '*',
    'Access-Control-Allow-Headers': '*'
  })
  ctx.body = {}
})

// 真实请求
router.post('/corsTest', ctx => {
  ctx.set({
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': '*',
    'Access-Control-Allow-Headers': '*'
  })
  ctx.body = { a: 123 }
})

$$('.page')  提供的新的api来选择元素   返回的是数组形式  可以使用forEach和map等方法
[body]
0: body,
length: 1,
__proto__: Array(0)

两元素交换位置
方法一：
        int a=10;
        int b=5;
        int temp;
        temp =a;
        a=b;
        b=temp;

方法二：
　　　　int  a  = 1;  //0001
　　      int b = 2;    //0010

            a = a+b;
            b=a-b;
            a=a-b;

方法三：

　　　　int  a  = 1;  //0001
           int b = 2;    //0010//          

  　　　a = a^b; //0011 
           b=a^b;   //0001
           a=a^b;   //0010
           
方法四:   [a,b] = [b,a]

JS新的用法

逻辑或赋值（||= ），
逻辑或赋值运算符 (x ||= y) 是在 x 是 false时对其赋值.
const a = { duration: 50, title: '' };

a.duration ||= 10;
console.log(a.duration); // 50

a.title ||= 'title is empty.';
console.log(a.title ); // "title is empty"
逻辑空赋值（??=）
逻辑空赋值运算符 (x ??= y) 仅在 x 是 (null 或 undefined) 时对其赋值。

逻辑与赋值（&&=）
(x &&= y) 仅仅当x为true时起作用，对其赋值

let a = 1;
let b = 0;

a &&= 2;
console.log(a);
// expected output: 2

b &&= 2;
console.log(b);
// expected output: 0
空值合并操作符（??）
当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。不能与 AND 或 OR 操作符共用
const foo = null ?? 'default string';
console.log(foo);
// expected output: "default string"

const baz = 0 ?? 42;
console.log(baz);
// expected output: 0

const foo2 = '' ?? 'default string';
可选链式操作符（?.）
允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined

边界判断
假如我们有一个拖动事件，规定被拖动模块需要在容器内部运动，这时就有边界判断，这其中又包括上，下，左，右四种单一边界，同时还有类似上右，上左等叠加边界，如果我们需要记录这种状态，通过位运算要比使用if判断要简单一些，上右下左四种边界分别用1，2，4，8表示，代码如下：

let flag = 0;
if (pos.left < left) flag = flag | 8;
if (pos.right > right) flag = flag | 2;
if (pos.bottom > bottom) flag = flag | 4;
if (pos.top < top) flag = flag | 1;
switch(flag) {
    // 上
    case 1: 
    // 右
    case 2:
    // 右上
    case 3:
    // 下
    case 4:
    // 右下
    case 6:
    // 左
    case 8:
    // 左上
    case 9:
    // 左下
    case 12:
    // code
}
同理，假如我们有一系列控制开关，通过 a | b | c的形式要比 '{a: true, b: true, c: true}' 简单的多。

判断奇偶
我们知道奇数的二进制最后一位必然为1，所以任意一个奇数 & 1 一定等于1。
// 判断奇偶
return number & 1 === 1

切换变量0和1
假如我们通过某个条件来切换一个值为0或者1
function update(toggle) {
    num = toggle ? 1 : 0;
}
update(true);
// 通过异或我们可以这么写
num = num ^ 1;

简单字符串加密
  const key = 313;
  function encryption(str) {
      let s = '';
      str.split('').map(item => {
        s += handle(item);
      })
      return s;
  }
  
  function decryption(str) {
    let s = '';
    str.split('').map(item => {
        s += handle(item);
    })
    return s;
  }
  
  function handle(str) {
      if (/\d/.test(str)) {
        return str ^ key;
      } else {
        let code = str.charCodeAt();
        let newCode = code ^ key;
        return String.fromCharCode(newCode);
      }
  }

  let init = 'hello world 位运算';
  let result = encryption(init);             // őŜŕŕŖęŎŖŋŕŝę乴軩窮
  let decodeResult = decryption(result);     // hello world 位运算

在二进制反码上加 1
我们可以看到一个数a取负相当于 ~a + 1, 即 -a = ~a + 1, 因此～a = -(a + 1)
~4+1  =>  -4
应用场景：

取整 （位运算花样取整）
~~(-5.88) // -5

判断数组中某项是否存在
// 常用判断
if (arr.indexOf(item) > -1) {
    // code
}
// 按位非    ~-1 = - (-1 + 1)
if (~arr.indexOf(item)) {
    // code
}

取整
a | 0 或者 a ^ 0 或者 a << 0 或者 a >> 0 相当于 parseInt(a)

2.35 | 0    // 2
-18.2 ^ 0   // -18
1.445 << 0  // 1
-3.14 >> 0  // -3
3.141 << 0 === parseInt(3.141)  // true

判断数值奇偶性
a & 1 相当于 a % 2

if (a & 1) {
  console.log(`${a}是奇数`)
} else {
  console.log(`${a}是偶数`)
}

判断数值正负性（局限于整数）
a >>> 0

if (a >>> 0 === a) {
  console.log(`${a}是正数`)
} else {
  console.log(`${a}是负数`)
}

判断两个数是否相等（局限于整数）
(a ^ b) === 0 相当于 a - b === 0

if (a ^ b) {
  console.log('a和b不相等')
} else {
  console.log('a和b相等')
}

交换两个数（局限于整数）
a ^= b; b ^= a; a ^= b 相当于 let c = a; a = b; b = c

let a = -1
let b = 99
a ^= b
b ^= a
a ^= b
console.log(a, b)   // 99 -1

乘法（局限于2的指数倍且操作数为整数）
a << b 相当于 a * 2 ** b

3 << 2  // 12
-5 << 1 // -10
34 << 2 === 34 * 2 ** 2 // true


var sendRequest = function () { 
    var random = Math.random(0, 1); 
    var status = !!(random >= 0.5); 
    return status; 
};
(function poll(time=1000) {
        console.log(time)
      if(!sendRequest()){
          return setTimeout(poll,time,time*1.5)
      }
})();

const a = 'asdasdasd&nbsp;asda&gt;asda&lt;asdasdasd'
const html2text = (v)=>{
    const div = document.createElement('div')
    div.innerHTML  =v
    return div.innerText
}
console.log(html2text(a))

/** 
 content 创建文件的内容 
 blob 类文件对象 
 name 创建的文件名 suffix 文件后缀 
 下面的就是创建一个a标签然后设置href以及download属性，并执行下载操作，然后移除a标签
 */
fileDownload(content, name = 'fileName', suffix = 'csv') {
  // 添加字节序标识，避免乱码
  const data = `\uFEFF${content}`;
  const blob = new Blob([data], { type: 'text/csv,charset=UTF-8' });
  const downloadElement = document.createElement('a');
  // 创建下载链接
  const href = window.URL.createObjectURL(blob);
  downloadElement.href = href;
  // 下载文件名
  downloadElement.download = `${name}.${suffix}`;
  document.body.appendChild(downloadElement);
  downloadElement.click();
  // 移除元素
  document.body.removeChild(downloadElement);
  // 释放blob对象
  window.URL.revokeObjectURL(href);
}

element中的select将对象作为值的方式
<el-select v-model="ruleForm.app" value-key="value" placeholder="请选择应用">
    <el-option
        v-for="item in appOptions"
        :key="item.value"
        :label="item.label"
        :value="item"
    />
</el-select>
ruleForm:{
    app:{label:'bbb',value:'bbb'},
},
appOptions:[
    {label:'aaa',value:'aaa'},
    {label:'bbb',value:'bbb'},
    {label:'ccc',value:'ccc'},
],

显示(本地)git所知道的所有本地和远程分支。
git branch -a

若要更新远程分支的本地列表，请执行以下操作：
git remote update origin --prune

git checkout develop_liuxingxing创建本地分支   并且关联到远程的develop_liuxingxing

对于复杂的系统，我们可能要开好几个分支来开发，那么怎样使用git合并分支呢？

合并步骤：
1、进入要合并的分支（如开发分支合并到master，则进入master目录）

git pull

2、查看所有分支是否都pull下来了

git branch -a

3、使用merge合并开发分支

git merge 分支名

4、查看合并之后的状态

git status 

5、有冲突的话，通过IDE解决冲突；

6、解决冲突之后，将冲突文件提交暂存区

git add 冲突文件

7、提交merge之后的结果

git commit 

如果不是使用git commit -m "备注" ，那么git会自动将合并的结果作为备注，提交本地仓库；

8、本地仓库代码提交远程仓库

git push

git将分支合并到分支，将master合并到分支的操作步骤是一样的；

使用git stash命令保存和恢复进度
git stash
保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行git status命令，就会发现当前是一个干净的工作区，没有任何改动。使用git stash save 'message...'可以添加一些注释

git stash list
显示保存进度的列表。也就意味着，git stash命令可以多次执行。

git stash pop [–index] [stash_id]
git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。
git stash pop --index 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区）
git stash pop stash@{1}恢复指定的进度到工作区。stash_id是通过git stash list命令得到的 
通过git stash pop命令恢复进度后，会删除当前进度。
git stash apply [–index] [stash_id]
除了不删除恢复的进度之外，其余和git stash pop 命令一样。

git stash drop [stash_id]
删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。

git stash clear
删除所有存储的进度。

Git Bash:

切换到要操作的项目文件夹 
命令行 : $ cd <ProjectPath>

查看项目的分支们(包括本地和远程) 
命令行 : $ git branch -a

删除本地分支 
命令行 : $ git branch -d <BranchName>

删除远程分支 
命令行 : $ git push origin --delete <BranchName>

查看删除后分支们 
命令行 : $ git branch -a

git怎么回退到某个历史版本

首先在 code.aliyun.com 的找到你所要回滚的分支提交记录，点击右侧红框中的连接即可得到 提交记录编号，截图如下：

2. 在Terminal 或者git控制条 执行 回退到某个版本命令

git reset --hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96 

3. 强制提交到master_ptu分支（具体需要提交到哪个分支请酌情修改，此例为提交到master_ptu分支）

git push -f -u origin master_ptu


js多层for循环中跳出
bbq:
for(var j=0;j<a.length;j++){
    ccc:
    for(var i =0;i<a.length;i++){
        if( i==5 ){
            break bbq; //直接跳出bbq外层循环
        }
    }
}

<router-view v-if="isRouterAlive"></router-view>


provide和inject的用法
provide (){
    return {
      reload:this.reload
    }
},
data(){
  return {
      isRouterAlive:true
  }
},
reload (){//方法中
    this.isRouterAlive = false
    this.$nextTick(function(){
      this.isRouterAlive = true
    })
}

inject:['reload'],//子组件中
this.reload()//在需要执行重新加载的步骤后面执行该函数


var obj = {m:{n:{p:{value:123}}}}
function getValue(obj,str){
  return str.split('.').reduce((prev,next)=>{
    return (prev && prev[next])? prev[next]:null
  },obj)
}
console.log(getValue(obj,'m.n.p.value'))

function deepObjectMerge(FirstOBJ, SecondOBJ) { 
    for (var key in SecondOBJ) {
        FirstOBJ[key] = FirstOBJ[key] && FirstOBJ[key].toString() === "[object Object]" ?
            deepObjectMerge(FirstOBJ[key], SecondOBJ[key]) : FirstOBJ[key] = SecondOBJ[key];
    }
    return FirstOBJ;
}

const setTimeout = (fn,timeout,...args)=>{
  const start = +new Date()
  let now,timer
  const loop = ()=>{
    timer = window.requestAnimationFrame(loop)
    now = +new Date()
    if(now-start>=timeout){
      fn.apply(this,args)
      window.cancelAnimationFrame(timer)
    }
  }
  window.requestAnimationFrame(loop)
}

function createRequest(tasks=[],pool=5){
  let results = []
  let running = 0
  let resultsLength = tasks.length
  return new Promise((resolve,reject)=>{
    next()
    function next(){
      while(running<pool && tasks.length){
        running++
        let task = tasks.shift()
        task().then(result=>{
          results.push(result)
        }).finally(()=>{
          running--
          next()
        })
      }
      results.length === resultsLength && resolve(results)
    }
  })
}

function deepClone(obj){
  function isObject(param){
    return (typeof param ==='object' || typeof param === 'function') && param !== null
  }

  if(!isObject(obj)){
    return obj
  }
  let cloneObj = Array.isArray(obj)?[]:{}
  for(let key in obj){
    if(obj.hasOwnProperty(key)){
      cloneObj[key] = isObject(obj[key])?deepClone(obj[key]):obj[key]
    }
  }
  return cloneObj
}

function instance_of(L,R){
  var prototype = R.prototype
  L = L.__proto__
  while(true){
    if(L === NULL){
      return false
    }
    if(prototype === L){
      return true
    }
    L = L.__proto__
  }
}

function foo(...args){
  const target = (...arg1)=>foo(...[...args,...arg1])
  target.getValue = args.reduce((p,n)=>p+n,0)
  return target
}

var longestCommonPrefix = function(strs) {
    if (strs === null || strs.length === 0) return "";
    let prevs = strs[0]
    for(let i = 1; i < strs.length; i++) {
        let j = 0
        for(; j < prevs.length && j < strs[i].length; j++) {
            if(prevs.charAt(j) !== strs[i].charAt(j)) break
        }
        prevs = prevs.substring(0, j)
        if(prevs === "") return ""
    }
    return prevs
};
const result = longestCommonPrefix(["flower","flow","flight"])
console.log(result)

const removeDuplicates = function(s, k) {
    let stack = []
    for(let c of s) {
        let prev = stack.pop()
        if(!prev || prev[0] !== c) {
            prev && stack.push(prev)
            stack.push(c)
        } else if(prev.length < k-1) {
            stack.push(prev+c)
        }
    }
    return stack.join('')
};
removeDuplicates('deeedbbcccbdaa',3)

1、获取字符串中的字符数
const characterCount = (str, char) => str.split(char).length - 1
2、 检查对象是否为空
const isEmpty = obj => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object
3、等待一定时间后执行
const wait = async (milliseconds) => new Promise((resolve) => setTimeout(resolve, milliseconds));
const test = async ()=>{
  await wait(1000)
  console.log('waited for 1 second')
}
test()
4、获取两个日期之间的天差
const daysBetween = (date1, date2) => Math.ceil(Math.abs(date1 - date2) / (1000 * 60 * 60 * 24))
daysBetween(new Date('2019-1-9'),new Date('2021-8-16'))
5、重定向到另一个 URL
const redirect = url => location.href = url
6、检查设备上的触摸支持
const touchSupported = () => ('ontouchstart' in window || DocumentTouch && document instanceof DocumentTouch)
7、在元素后插入一串 HTML
const insertHTMLAfter = (html, el) => el.insertAdjacentHTML('afterend', html)
8、打乱数组  
const shuffle = arr => arr.sort(() => 0.5 - Math.random())
9、在网页上获取选定的文本
const getSelectedText = () => window.getSelection().toString()
10、 获取一个随机布尔值
const getRandomBoolean = () => Math.random() >= 0.5
11、计算数组的平均值
const average = (arr) => arr.reduce((a, b) => a + b) / arr.length

给定一个字符串，逐个翻转字符串中的每个单词。
输入: "the sky is blue"
输出: "blue is sky the"

输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
const reverseWords = function(s) {
    return s.trim().replace(/\s+/g, ' ').split(' ').reverse().join(' ')
};

let triangleNumber = function(nums) {
    if(!nums || nums.length < 3) return 0
    let count = 0
    // 排序  先排序  以最长的边为最大  然后遍历前面的两边之和大于第三边 
    // 先数组排序，排序完后，固定最长的边，利用双指针法判断其余边
    nums.sort((a, b) => a - b) 
    for(let k = nums.length - 1; k > 1; k--){
        let i = 0, j = k - 1
        while(i < j){ 
            if(nums[i] + nums[j] > nums[k]){
                count += j - i
                j--
            } else {
                i++
            }
        }
    }       
    return count
}
console.log(triangleNumber([2,2,3,4,5]))

content-visibility是一个非常实用的CSS属性，通过一行CSS可以代替虚拟滚动、上拉加载更多等多种长列表渲染优化方式。
content-visibility: auto;
contain-intrinsic-size: 312px; // 添加此行
可以使用contains-intrinsic-size属性，为上面的card添加：contains-intrinsic-size：312px;，这会给内容附一个初始高度值。（如果高度不固定也可以附一个大致的初始高度值，会使滚动条问题相对减少）
      
1-1. 设置input 的placeholder的字体样式
设置input占位符的样式
input::-webkit-input-placeholder {    /* Chrome/Opera/Safari */
    color: red;
}
input::-moz-placeholder { /* Firefox 19+ */  
    color: red;
}
input:-ms-input-placeholder { /* IE 10+ */
    color: red;
}
input:-moz-placeholder { /* Firefox 18- */
    color: red;
}
<input type="text" placeholder="请设置用户名">

设置input聚焦时的样式
input:focus {   
  background-color: red;
}
取消input的边框
border: none;
outline: none;

1-2. 单行和多行文本超出省略号
// 单行文本出现省略号
width: 300px;
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
word-break: break-all;

// 多行文本出现省略号
display: -webkit-box; /*重点，不能用block等其他，将对象作为弹性伸缩盒子模型显示*/
-webkit-box-orient: vertical; /*从上到下垂直排列子元素（设置伸缩盒子的子元素排列方式）*/
-webkit-line-clamp: 3; /*行数，超出三行隐藏且多余的用省略号表示...*/
line-clamp: 3;
word-break: break-all;
overflow: hidden;
max-width: 100%;
1-3. 负边距使用技巧
规律: 左为负时，是左移，右为负时，是左拉。上下与左右类似
1-4. 定位同时设置方位情况
规律: 绝对定位和固定定位时，同时设置 left 和 right 等同于隐式地设置宽度
span{
  border:1px solid red;
  position: absolute;
  left:0;
  right:0;
   /* 等同于设置  width:100%;display:block */
}
1-5. 相邻兄弟选择器之常用场景
ul{
  width: 500px;
   margin:auto;
   list-style: none;
   padding:0;
   border:1px solid red;
   text-align: center;
 }
 li+li{
   border-top:1px solid red;
 }
1-6. outline属性的妙用技巧(区别: outline不计算大小 border计算大小)
1-7. 隐藏滚动条或更改滚动条样式
.scroll-container {
   width: 500px;
   height: 150px;
   border: 1px solid #ddd;
   padding: 15px;
   overflow: auto;     /*必须*/
 }
 .scroll-container::-webkit-scrollbar {
   width: 8px;
   background: white;
 }
 .scroll-container::-webkit-scrollbar-corner,
   /* 滚动条角落 */
 .scroll-container::-webkit-scrollbar-thumb,
 .scroll-container::-webkit-scrollbar-track {      /*滚动条的轨道*/
   border-radius: 4px;
 }

 .scroll-container::-webkit-scrollbar-corner,
 .scroll-container::-webkit-scrollbar-track {
   /* 滚动条轨道 */
   background-color: rgba(180, 160, 120, 0.1);
   box-shadow: inset 0 0 1px rgba(180, 160, 120, 0.5);
 }

 .scroll-container::-webkit-scrollbar-thumb {
   /* 滚动条手柄 */
   background-color: #00adb5;
 }
1-8. 纯CSS绘制三角形
/* 正三角 */
.up-triangle {
   width: 0;
   height: 0;
   border-style: solid;
   border-width: 0 25px 40px 25px;
   border-color: transparent transparent rgb(245, 129, 127) transparent;
 }

 /* 倒三角 */
 .down-triangle {
   width: 0;
   height: 0;
   border-style: solid;
   border-width: 40px 25px 0 25px;
   border-color:  rgb(245, 129, 127) transparent transparent transparent;
 }
 div:last-child {
   margin-top: 1rem;
 }
1-9. 虚线框绘制技巧
.dotted-line {
  width: 800px;
  margin: auto;
  padding: 20px;
  border: 1px dashed transparent;
  background: linear-gradient(white, white) padding-box, repeating-linear-gradient(-45deg, red 0, #ccc .25em, white 0, white .75em);
}

1-10. 卡券效果制作
.coupon {
 width: 300px;
  height: 100px;
  line-height: 100px;
  margin: 50px auto;
  text-align: center;
  position: relative;
  background: radial-gradient(circle at right bottom, transparent 10px, #ffffff 0) top right /50% 51px no-repeat,
  radial-gradient(circle at left bottom, transparent 10px, #ffffff 0) top left / 50% 51px no-repeat,
  radial-gradient(circle at right top, transparent 10px, #ffffff 0) bottom right / 50% 51px no-repeat,
  radial-gradient(circle at left top, transparent 10px, #ffffff 0) bottom left / 50% 51px no-repeat;
  filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, .2));
}
.coupon span {
  display: inline-block;
  vertical-align: middle;
  margin-right: 10px;
  color: red;
  font-size: 50px;
  font-weight: 400;
}

<p class="coupon">
 <span>200</span>优惠券
</p>

1-11. 隐藏文本的常用两种方法  
text-indent: -9999px; 或者 font-size: 0;
1-12. 表格边框合并
table{
  border-collapse: collapse;
}
1-13滚动条移入宽度 颜色样式改变
.scroll-container {
  width: 500px;
  height: 150px;
  border: 1px solid #ddd;
  padding: 15px;
  overflow: auto;     /*必须*/
}
.scroll-container::-webkit-scrollbar{
  height: 9px !important;
  width: 9px !important;
}
.scroll-container::-webkit-scrollbar-thumb {
  border-radius: 0;
  border-style: dashed;
  background-color: rgba(15, 65, 83, 0.4);
  border-color: transparent;
  border-width: 1.5px;
  background-clip: padding-box;
}
.scroll-container::-webkit-scrollbar-thumb:hover {
  background: hsl(210deg, 50%, 50%);
} 

1-14一行 CSS 为网页添加暗黑模式支持
html[theme='dark-mode'] {
    filter: invert(1) hue-rotate(180deg);
}
我们还将向HTML元素添加一个 transition ，以确保过渡不会过于花哨!
html {
    transition: color 300ms, background-color 300ms;
}
1-15实现隐藏滚动条同时又可以滚动
.demo::-webkit-scrollbar {
  display: none; /* Chrome Safari */
}
.demo {
  scrollbar-width: none; /* firefox */
  -ms-overflow-style: none; /* IE 10+ */
  overflow-x: hidden;
  overflow-y: auto;
}
1-16CSS实现文本两端对齐
.wrap {
    text-align: justify;
    text-justify: distribute-all-lines;  //ie6-8
    text-align-last: justify;  //一个块或行的最后一行对齐方式
    -moz-text-align-last: justify;
    -webkit-text-align-last: justify;
}
1-17使元素鼠标事件失效
.wrap {
  // 如果按tab能选中该元素，如button，然后按回车还是能执行对应的事件，如click。
 pointer-events: none;
 cursor: default;
}
1-18禁止用户选择
.wrap {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
1-19字母大小写转换
p {text-transform: uppercase}  // 将所有字母变成大写字母
p {text-transform: lowercase}  // 将所有字母变成小写字母
p {text-transform: capitalize} // 首字母大写
p {font-variant: small-caps}   // 将字体变成小型的大写字母
1-20识别字符串里的 '\n' 并换行
body {
   white-space: pre-line;
}
1-21CSS显示链接之后的URL
<a href="//www.webqdkf.com">有课前端网</a>
<style>
a:after {content: " (" attr(href) ")";}
</style>
//效果 有课前端网(//www.webqdkf.com)
1-22select内容居中显示、下拉内容右对齐
select{
    text-align: center;
    text-align-last: center;
}
select option {
    direction: rtl;
}
1-23修改input输入框中光标的颜色不改变字体的颜色
input{
    color:  #fff;
    caret-color: red;
}
1-24让div里的图片和文字同时上下居中
这里不使用flex布局的情况。通过vertival-align
.wrap {
  height: 100,
  line-height: 100
}
img {
  vertival-align：middle
}
// vertical-align css的属性vertical-align用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。只对行内元素、表格单元格元素生效，不能用它垂直对齐块级元素
// vertical-align：baseline/top/middle/bottom/sub/text-top;
1-25实现宽高等比例自适应矩形
.scale {
  width: 100%;
  padding-bottom: 56.25%;
  height: 0;
  position: relative; 
}
.item {
  position: absolute; 
  width: 100%;
  height: 100%;
  background-color: 499e56;
}    
<div class="scale">
     <div class="item">
         这里是所有子元素的容器
     </div>
 </div>
1-26transfrom的rotate属性在span标签下失效
span {
  display: inline-block
}
1-27文字渐变效果实现
.text_signature {
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-image: linear-gradient(to right, #ec2239, #40a4e2,#ea96f5);
    width: 320px;
}
1-28实现文字描边
.stroke {
      -webkit-text-stroke: 1px greenyellow;
     text-stroke: 1px greenyellow;
}
1-29图片自适应object-fit
img{
    width: 100%;
    height: 100%;
    object-fit: cover;
}

1. Vue 3.0 性能提升主要是通过哪几方面体现的？
1.响应式系统提升
vue2在初始化的时候，对data中的每个属性使用definepropery调用getter和setter使之变为响应式对象。如果属性值为对象，还会递归调用defineproperty使之变为响应式对象。vue3使用proxy对象重写响应式。proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性，另外有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。

优势：
可以监听动态新增的属性；
可以监听删除的属性 ；
可以监听数组的索引和 length 属性；
2. 编译优化
优化编译和重写虚拟dom，让首次渲染和更新dom性能有更大的提升 vue2 通过标记静态根节点,优化 diff 算法 vue3 标记和提升所有静态根节点,diff 的时候只比较动态节点内容Fragments, 模板里面不用创建唯一根节点,可以直接放同级标签和文本内容

静态提升
patch flag, 跳过静态节点,直接对比动态节点,缓存事件处理函数

3. 源码体积的优化
vue3移除了一些不常用的api，例如：inline-template、filter等 使用tree-shaking

2. Composition Api 与 Vue 2.x使用的Options Api 有什么区别？
Options Api
包含一个描述组件选项（data、methods、props等）的对象 options；API开发复杂组件，同一个功能逻辑的代码被拆分到不同选项 ；使用mixin重用公用代码，也有问题：命名冲突，数据来源不清晰；

composition Api
vue3 新增的一组 api，它是基于函数的 api，可以更灵活的组织组件的逻辑。解决options api在大型项目中，options api不好拆分和重用的问题。

3. Proxy 相对于 Object.defineProperty
有哪些优点？proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性，另外有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。

可以* 监听数组变化
可以劫持整个对象
操作时不是对原对象操作,是 new Proxy 返回的一个新对象
可以劫持的操作有 13 种

4. Vue 3.0 在编译方面有哪些优化？
vue.js 3.x中标记和提升所有的静态节点，diff的时候只需要对比动态节点内容；

Fragments（升级vetur插件):
template中不需要唯一根节点，可以直接放文本或者同级标签静态提升(hoistStatic),当使用 hoistStatic 时,所有静态的节点都被提升到 render 方法之外.只会在应用启动的时候被创建一次,之后使用只需要应用提取的静态节点，随着每次的渲染被不停的复用。patch flag, 在动态标签末尾加上相应的标记,只能带 patchFlag 的节点才被认为是动态的元素,会被追踪属性的修改,能快速的找到动态节点,而不用逐个逐层遍历，提高了虚拟dom diff的性能。缓存事件处理函数cacheHandler,避免每次触发都要重新生成全新的function去更新之前的函数 tree shaking 通过摇树优化核心库体积,减少不必要的代码量

5.  Vue.js 3.0 响应式系统的实现原理？
1. reactive
设置对象为响应式对象。接收一个参数，判断这参数是否是对象。不是对象则直接返回这个参数，不做响应式处理。创建拦截器handerler，设置get/set/deleteproperty。

get
收集依赖（track）；
如果当前 key 的值是对象，则为当前 key 的对
象创建拦截器 handler, 设置 get/set/deleteProperty；
如果当前的 key 的值不是对象，则返回当前 key 的值。

set
设置的新值和老值不相等时，更新为新值，并触发更新（trigger）。deleteProperty 当前对象有这个 key 的时候，删除这个 key 并触发更新（trigger）。

2. effect
接收一个函数作为参数。作用是：访问响应式对象属性时去收集依赖

3. track
接收两个参数：target 和 key
－如果没有 activeEffect，则说明没有创建 effect 依赖－如果有 activeEffect，则去判断 WeakMap 集合中是否有 target 属性－WeakMap 集合中没有 target 属性，则 set(target, (depsMap = new Map()))－WeakMap 集合中有 target 属性，则判断 target 属性的 map 值的 depsMap 中是否有 key 属性－depsMap 中没有 key 属性，则 set(key, (dep = new Set())) －depsMap 中有 key 属性，则添加这个 activeEffect

4.trigger
判断 WeakMap 中是否有 target 属性，WeakMap 中有 target 属性，则判断 target 属性的 map 值中是否有 key 属性，有的话循环触发收集的 effect()。

JSON.stringify()  会将函数转成undefined  NaN转成'null'
JSON.stringify({f:()=>{},a:true,b:null,c:NaN})==》'{"a":true,"b":null,"c":null}'
 
数组中会修改原数组的方法
1.pop() 删除 数组 最后一个元素；
2.shift() 删除 数组 第一个元素；
3.push() 数组 最后 添加 一个 元素；
4.unshift() 数组 开头 添加 一个 元素；
5.sort() 数组 排序
6.splice() 数组 删除 替换 插入 元素
7.reverse() 数组 反转

不会修改原数组的方法  
concat():用于连接两个或多个数组，仅会返回被连接数组的一个副本，arrayObject.concat(arrayX,arrayX,……,arrayX)
join():返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来,arrayObject.join(separator)
slice():如果数组是空的arrayObject.slice(start,end)
concat() //连接数组并返回结果
every() //检测数组元素的每个元素是否都符合条件,返回true or false
some() //检测数组元素的每个元素是否有符合条件,返回true or false
filter() //检测数组元素并返回符合条件的元素组成的数组
find() //返回数组中满足提供的测试函数的第一个元素的值
map() //通过指定函数处理数组每个元素并返回处理后的数组
toString() //返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串
valueOf()  //返回同一数组中的所有项 
indexOf()和 lastIndexOf()

20 个杀手级 JavaScript 单行代码
1.获取浏览器Cookie的值
const cookie = name => `; ${document.cookie}`.split(`; ${name}=`).pop().split(';').shift();
cookie('_ga');
// Result: "GA1.2.1929736587.1601974046"

2.颜色RGB转十六进制
const rgbToHex = (r, g, b) => "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
rgbToHex(0, 51, 255); 
// Result: #0033ff

3.复制到剪贴板
const copyToClipboard = (text) => navigator.clipboard.writeText(text);
copyToClipboard("Hello World");

4.检查日期是否合法
const isDateValid = (...val) => !Number.isNaN(new Date(...val).valueOf());
isDateValid("December 17, 1995 03:24:00");
// Result: true

5.查找日期位于一年中的第几天
const dayOfYear = (date) =>
      Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);
dayOfYear(new Date());
// Result: 272

6.英文字符串首字母大写
const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1)
capitalize("follow for more")
// Result: Follow for more

7.计算2个日期之间相差多少天
const dayDif = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)   86400000是一天的毫秒数1000*60*60*24
dayDif(new Date("2020-10-21"), new Date("2021-10-22"))
// Result: 366

8.清除全部Cookie
const clearCookies = document.cookie.split(';').forEach(cookie => document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date(0).toUTCString()};path=/`));

9.生成随机十六进制颜色
const randomHex = () => `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, "0")}`;
 console.log(randomHex());
// Result: #92b008

10.数组去重
const removeDuplicates = (arr) => [...new Set(arr)];
console.log(removeDuplicates([1, 2, 3, 3, 4, 4, 5, 5, 6]));
// Result: [ 1, 2, 3, 4, 5, 6 ]

11.从 URL 获取查询参数
const getParameters = (URL) => {
  URL = JSON.parse(
    '{"' +
      decodeURI(URL.split("?")[1])
        .replace(/"/g, '\\"')
        .replace(/&/g, '","')
        .replace(/=/g, '":"') +
      '"}'
  );
  return JSON.stringify(URL);
};
getParameters(window.location);
// Result: { search : "easy", page : 3 }
或者更为简单的：
Object.fromEntries(new URLSearchParams(window.location.search))
// Result: { search : "easy", page : 3 }

12.时间处理
const timeFromDate = date => date.toTimeString().slice(0, 8);
console.log(timeFromDate(new Date(2021, 0, 10, 17, 30, 0))); 
// Result: "17:30:00"

13.校验数字是奇数还是偶数
const isEven = num => num % 2 === 0;
console.log(isEven(2)); 
// Result: True

14.求数字的平均值
const average = (...args) => args.reduce((a, b) => a + b) / args.length;
average(1, 2, 3, 4);
// Result: 2.5

15.回到顶部
const goToTop = () => window.scrollTo(0, 0);
goToTop();

16.翻转字符串
const reverse = str => str.split('').reverse().join('');
reverse('hello world');     
// Result: 'dlrow olleh'

17.校验数组是否为空
const isNotEmpty = arr => Array.isArray(arr) && arr.length
isNotEmpty([1, 2, 3]);
// Result: true

18.获取用户选择的文本
const getSelectedText = () => window.getSelection().toString();
getSelectedText();

19.打乱数组
const shuffleArray = (arr) => arr.sort(() => 0.5 - Math.random());
console.log(shuffleArray([1, 2, 3, 4]));
// Result: [ 1, 4, 3, 2 ]

20.检查用户的设备是否处于暗模式
const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
console.log(isDarkMode) 
// Result: True or False

21.Chrome 浏览器input输入框值为空时会自动填充记录的账号密码
当input是passworde时，记住密码之后，所有地方的input都会自动填充。（加上autocomplete=“new-password”）

22.img标签上和盒子背景图片设置display:none   img标签会发送http请求不会阻止渲染   背景图片不会发送请求也不会阻止渲染   如果是设置visibility:hidden   会发送请求也会渲染只是视觉上看不见

23.for in常用来遍历对象   for of用了遍历可迭代对象  set map array arguments 等  
for in会遍历自身及原型链上的可枚举属性    （可以通过hasOwnProperty()来判断是否是该对象本身拥有的属性）
Object.keys()会将对象自身的可枚举属性作为数组输出
Object.getOwnPropertyNames()会将自身的所有属性的key输出  (包含不可枚举的) 

html篇
一:HTML5新增属性
1.1contextmenu   contextmenu的作用是指定右键菜单。
<div id="div1" style="height:900px; background: lightgreen;" contextmenu="menuShare">
</div>
<menu id="menuShare" type="context">
    <menuitem label="分享到QQ空间" onclick="alert('QQ');"></menuitem>
    <menuitem label="分享到朋友圈" onclick="alert('朋友圈');"></menuitem>
    <menuitem label="分享到微博" onclick="alert('微博');"></menuitem>
</menu>
menuitem 属性：
label：菜单项显示的名称
icon：在菜单项左侧显示的图标
onclick：点击菜单项触发的事件

1.2、contentEditable  规定是否可编辑元素的内容
document.body.contentEditable=true; 可以修改已发布网站
<h2>contentEditable属性</h2>
<div contenteditable>
    Hello contentEditable
</div>

1.3、hidden
hidden属性用于隐藏该元素。一旦使用了此属性，则该元素就不会在浏览器中被显示
<div hidden>
    Hello Hidden
</div>

1.4、draggable 规定元素是否可拖拽

1.5、data-* data-*属性能让用户自定义属性的方式来存储数据
<span id="spanData" data-order-amount=100></span>
取值：
getAttribute('data-order-amount')  
dataset.orderAmount
jQuery中的data()方法同样可以访问

console.log(spanData.getAttribute('data-order-amount'))
console.log(spanData.dataset.orderAmount)
console.log($("#spanData").data("student-name"));

1.6、placeholder占位属性
logIn .loginCon .boxUser form input::-webkit-input-placeholder{
  color:#DCDCDC;
}
.logIn .loginCon .boxUser form input:-moz-placeholder{
  color:#DCDCDC;
}
.logIn .loginCon .boxUser form input::-moz-placeholder{
  color:#DCDCDC;
}
.logIn .loginCon .boxUser form input:-ms-input-placeholder{
  color:#DCDCDC;
}
-moz代表firefox浏览器私有属性
-ms代表IE浏览器私有属性
-webkit代表chrome、safari私有属性
-o-代表opera浏览器私有属性

1.7、required必填属性
<input type="url" name="blog" id="blog" value="" required />

1.8、pattern正则属性
<input type="text" required pattern="^[0-9a-zA-Z]{6,16}$" />请输入a-zA-Z0-9且长度6-16位的字符

1.9、autofocus自动聚焦属性
<input type="url" name="blog" id="blog" value="" required autofocus="autofocus"/>

1.10、autocomplete自动完成属性
当表单元素设置了自动完成功能后，会记录用户输入过的内容，双击表单元素会显示历史输入。
<input type="text" name="username" autocomplete="on/off" /> 该属性默认是打开的。

1.11、novalidate不验证属性
novalidate 属性规定在提交表单时不应该验证 form 或 input 域。
<form action="demo_form.asp" method="get" novalidate="true">

1.12、multiple多选属性
multiple 属性规定输入域中可选择多个内容，如：email 和 file

二:HTML表单新功能解析
2.1表单结构更自由
2.2邮箱、url 、日期、数字、滑块类型、搜索输入、电话、color输入类型
<input type='email'>
<input type='url'>
<input type='date'>
<input type='time'>
<input type='month'>
<input type='week'>
<input type='datetime'>
<input type='datetime-local'>
<input type='number'>
<input type='range'>
<input type='search'>
<input type='tel'>
<input type='color'>

2.3新增表单元素datalist
<datalist id="uselist" name="uselist">
    <option>BMW</option>
    <option>Ford</option>
    <option>Volvo</option>
</datalist>
<input type="text" list="uselist">

三、特殊的超链接
3.1、短信
<a href='sms:15919218899'>短信</a>
在手机端，当点击短信时将实现发送短信功能，进入发送短信界面，自动填写好手机号码

3.2、电话
<a href="tel:15919218899">电话</a>
在手机端，当点击电话时将实现拨打电话功能，进入拨打电话界面，自动填写好手机号码

3.3、邮件
<a href="mailto:99519876@qq.com">邮件</a>
点击邮件时将启动客户端发送邮件的软件如outlook,foxmail等

3.4、QQ客户
<a target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=99518888&site=qq&menu=yes" alt="点击这里给我发消息" title="点击这里给我发消息">QQ客服</a>

3.5、地图
<a href="http://map.baidu.com/mobile/webapp/search/search/qt=s&wd=%E7%8F%A0%E6%B5%B7%E6%B8%AF&c=348&searchFlag=bigBox&version=5&exptype=dep/vt=map/?fromhash=1">地图</a>
在手机端可以直接进入baidu的地图

CSS3有哪些新特性？
新增选择器 p:nth-child（n）{color: rgba（255, 0, 0, 0.75）}

弹性盒模型 display: flex;

多列布局 column-count: 5;

媒体查询 @media （max-width: 480px） {.box: {column-count: 1;}}

个性化字体 @font-face{font-family:BorderWeb;src:url（BORDERW0.eot）；}

颜色透明度 color: rgba（255, 0, 0, 0.75）；

圆角效果 border-radius border-radius：5px 4px 3px 2px;/*四个值分别代表左上角，右上角，右下角，左下角，顺时针*/

css3边框 背景图 border-image
border-image：border-image-source [border-image-slice] [border-image-width] [border-image-outset] [border-image-repeat];

css3颜色 颜色之RGBA color:rgba(R,G,B,A)

渐变 background:linear-gradient（red, green, blue）；

盒子阴影 box-shadow:3px 3px 3px rgba（0, 64, 128, 0.3）；

倒影 box-reflect: below 2px;

文字装饰 text-stroke-color: red;

文字阴影 text-shadow:5px 2px 6px rgba(64, 64, 64, 0.5);

文字溢出 text-overflow:ellipsis;

背景效果 background-size: 100px 100px;

边框效果 border-image:url（bt_blue.png） 0 10;

css3颜色 渐变色彩 liner-gradient(to bottom,#fff,#999)/*liner-gradient为渐变类型-线性渐变，径向为radial，to bottom渐变方向，后面两个参数表示颜色的起始点和结束点，可以有两至多值*/

CSS3背景 background-origin
background-origin设置元素背景图片的原始起始位置。
background-origin:border-box |padding-box|content-box;
需要注意的是，background-origin属性只有在背景设置为no-repeat的情况下起作用，如果背景不是no-repeat，该属性无效，会从边框开始显示。

CSS3背景 background-clip
background-clip：border-box | padding-box | content-box |no-clip;

转换 过渡和3D
旋转 transform: rotate（20deg）；

倾斜 transform: skew（150deg, -10deg）；

位移 transform:translate（20px, 20px）；

缩放 transform: scale（。5）；

平滑过渡 transition: all .3s ease-in .1s;

动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;
animation:
[animation-name] [animation-duration] // 动画的名称、持续时间
[animation-timing-function][animation-delay] // 关于时间的函数(properties/t)、延迟时间
[animation-iteration-count] [animation-direction] // 播放次数、播放顺序
[animation-fill-mode] [animation-play-state]; // 播放前或停止后设置相应样式、控制动画运行或暂停
1.时间函数（animation-timing-function）
animation-timing-function属性定义了动画的播放速度曲线。
可选配置参数为:
ease、
ease-in、
ease-out、
ease-in-out、
linear、
cubic-bezier(number, number, number, number)
2.动画方向（animation-direction）
animation-direction属性表示CSS动画是否反向播放。
可选配置参数为:

single-animation-direction = normal | reverse | alternate | alternate-reverse

animation-direction: normal 正序播放
animation-direction: reverse 倒序播放
animation-direction: alternate 交替播放
animation-direction: alternate-reverse 反向交替播放
animation-direction: normal, reverse
animation-direction: alternate, reverse, normal
3.动画延迟（animation-delay）
animation-delay属性定义动画是从何时开始播放，即动画应用在元素上的到动画开始的这段时间的长度。
默认值0s，表示动画在该元素上后立即开始执行。
该值以秒(s)或者毫秒(ms)为单位。
4.动画迭代次数（animation-iteration-count）
animation-iteration-count该属性就是定义我们的动画播放的次数。次数可以是1次或者无限循环。
默认值只播放一次。

single-animation-iteration-count = infinite | number
5.动画填充模式（animation-fill-mode）
animation-fill-mode是指给定动画播放前后应用元素的样式。

single-animation-fill-mode = **none **| **forwards **| **backwards **| both

animation-fill-mode: none 动画执行前后不改变任何样式
animation-fill-mode: forwards 保持目标动画最后一帧的样式
animation-fill-mode: backwards 保持目标动画第一帧的样式
animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。
6.动画播放状态（animation-play-state）
animation-play-state: 定义动画是否运行或者暂停。可以确定查询它来确定动画是否运行。
默认值为running

animation-play-state = running | paused

running 动画正常播放
paused 动画暂停播放

js实现并发控制
async function asyncPool(poolLimit,array,iteratorFn){
  const ret = []//存储所以的异步任务
  const executing = []//存储正在执行的异步任务
  for(const item of array){
    //调用iteratorFn创建异步任务
    const p = Promise.resolve().then(_=>iteratorFn(item))
    //保存新的异步任务
    ret.push(p)
    //当poolLimit值小于或等于总任务呀的个数时 进行并发控制
    if(poolLimit<=array.length){
      //当任务完成后 从正在执行的任务数组中移除已完成的任务
      const e = p.then(_=>executing.splice(executing.indexOf(e),1));
      executing.push(e) // 保存正在执行的异步任务
      if(executing.length === poolLimit){
        await Promise.race(executing.map(item=>{
          return item.catch(error=>error)
        }))
      }
    }
  }
  return Promise.all(ret.map(item=>item.catch(error=>error)))
}
const timeout = i=>new Promise((resolve,reject)=>{
  setTimeout(()=>{
    console.log(i)
    if(i===2000){
      reject({error,i})
    }else{
      resolve({success:i})
    }
  },i)
})
asyncPool(2,[1000,1000,1000,1000,1000,1000,1000,1000],timeout).then(res=>{
  console.log('res',res)
})

new Map()的经典使用   二维数组中获取数据
const a  = [['asdasd',3434],['3434',45454]]
new Map(a).get('asdasd')

网站控制台动态显示图片
const imgUrl = 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fphoto%2F2010-5-2%2Fenterdesk.com-B8767F2D8BADB3BD15975D4AD335523C.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646903201&t=a6a2c5f60a963bc16277aa723e8c77e2'
function consoleImg(url){
  let myImg = new Image()
  myImg.onload = function(){
    const style = `
      font-size:100px;
      padding-right:100px;
      background-image:url(${url});
      background-repeat:no-repeat;
      background-size:100px 100px;
    `
    console.log('%c ',style)
  }
  myImg.src = url
}
consoleImg(imgUrl)

采用垃圾回收机制解决栈溢出的问题
let res = {a:1,b:2}
res.c = res
console.log(res)
let cache = []
let str = JSON.stringify(res,(key,value)=>{
  if(value!==null && typeof(value) === 'object'){
    if(cache.includes(value)){
      return
    }
    cache.push(value)
  }
  return value
})
cache = null
console.log(str)

数组和字符串新增at方法  通过索引获取值
const arr = [1,2,3]
console.log(arr[-1]) undefined
console.log(arr.at(-1)) 3
const str = 'tom'
console.log(str[-1]) undefined
console.log(str.at(-1)) m

js获取深层次对象嵌套里面的值
const safeGet = (obj,path) =>{
  const keys = path.split('.')
  for(const key of keys){
    if(obj){
      obj = obj[key]
    }
  }
  return obj
}
const obj1 = {data:{config:{style:{color:'#333'}}}}
console.log(safeGet(obj1,'data.config.style.color'))
const safeGet1 = (obj,fieldArr) => {
  return fieldArr.reduce(function(prev, next) {
    return (prev && prev[next]) ? prev[next] : null;
  }, obj);
}
console.log(safeGet1(obj1,['data','config','style','color']))

js采用字符串的substr方法对小数点位数进行统计
function getDecimalPlaces = (num)=>{
  if(Math.floor(num) === num){
    return 0
  }
  let len = 0
  const str = String(num)
  const pointIndex = str.indexOf('.')
  len = str.substr(pointIndex+1).length
  return len
}

数字的加法运算 0.1+0.2
const add = (num1,num2) =>{
  let result = 0
  const num1Len = getDecimalPlaces(num1)
  const num2Len = getDecimalPlaces(num2)
  const maxLen = num1Len>num2Len?num1Len:num2Len
  const maxTimes = Math.pow(10,maxLen)
  result = (num1*maxTimes + num2*maxTimes) / maxTimes
  return result
}
数字的乘法运算 0.1*0.2
const mulFn = (num1,num2)=>{
  let result = 0
  const num1Len = getDecimalPlaces(num1)
  const num2Len = getDecimalPlaces(num2)
  const num1Times = Math.pos(10,num1Len)
  const num2Times = Math.pos(10,num2Len)
  const totalTimes = num1Times*num2Times
  result = (num1*num1Times)*(num2*num2Times)/totalTimes
  return result
}
数字的除法运算 0.01/0.2
const divsionFn = (num1,num2)=>{
  let result = 0
  const num1Len = getDecimalPlaces(num1)
  const num2Len = getDecimalPlaces(num2)
  const maxLen = Math.max(num1Len,num2Len)
  const maxTimes = Math.pow(10,maxLen)
  result = (num1*maxTimes)/(num2*maxTimes)
  return result
}

利用余数实现倒计时
const closeDate = new Date('2022-02-01 00:00:00')
function countDown(){
  let now = new Date()
  let timer = null
  let timeStamp = closeDate - now
  if(timeStamp<=0){
    clearTimeout(timer)
    return 0
  }
  let day,hour,minute,second;
  day = Math.floor(timeStamp/1000/60/60/24)
  hour = Math.floor(timeStamp/1000/60/60%24)
  minute = Math.floor(timeStamp/1000/60%60)
  second = Math.floor(timeStamp/1000%60)
  daySpan.innerHTML = day+'天'
  hourSpan.innerHTML = hour+'时'
  minuteSpan.innerHTML = minute+'分'
  secondSpan.innerHTML = second+'秒'
  timer = setTimeout(countDown,1000)
}
countDown()

前端深度判断两组数据是否完全相同使用JSON.stringify(obj1) === JSON.stringify(obj2)

一行代码实现五星好评
function star(num){
  return ["★".repeat(num),"☆".repeat(5-num)].join("")
}
console.log(`%c${star(3)}`,'font-size:36px;color:#f00')

5个你可能不知道的CSS属性
1. font-display  
auto：默认值。这相当于根本不使用该属性，结果是浏览器隐藏文本，当自定义字体完成加载后再显示文本。
block：浏览器在等待自定义字体加载时隐藏文本的时间减少了（例如1秒）。如果这段期间自定义字体未加载好，文本会应用备用字体呈现出来。同时，浏览器将无限期地等待自定义字体加载，并且自定义字体加载完成后对文本应用自定义字体。
swap: 浏览器将立即展示后备字体，同时加载自定义字体。当自定义字体加载成功后，浏览器会使用自定义字体替换后备字体。 大多数情况下，这就是我们所追求的效果，之前提及到的JavaScript脚本实现的功能就基本和这个是一致的。
fallback: 使用自定义字体渲染的文本在短时间内 (大约 100ms) 不可见，之后浏览器将持续加载自定义字体，这个期间，文本将以无样式的状态呈现，当自定义字体加载好了之后，文本将会被赋予自定义的字体。但是，如果加载字体耗时过长，文本将会使用后备字体，并且不再会使用自定义字体替换（即使后续自定义字体加载成功）。
optional 效果和fallback几乎一样，都是先在极短的时间内文本不可见，然后再自定义字体没有加载好之前使用后备字体。不过optional选项可以让浏览器自由决定是否使用甚至加载自定义字体。选择权交给浏览器的原因是，当用户的网络环境不好的时候，加载字体也许并不是一个好的选择。当这些自定义字体不影响网页的品牌形象或者无碍设计的时候，这个值可能是个很好的选择。

2. contain
contain属性允许开发者声明当前元素和它的内容尽可能的独立于其他部分的 Dom 树。
但这在实践中意味着什么呢？ 这意味着如果您有一个具有固定高度和宽度的小部件（独立的部分），当你想要更新它的内容和样式的时候，使用这个属性可以通过限定浏览器的计算来避免影响到其他的DOM结构。 浏览器将执行较少的计算，从而获得更好的性能。
none：默认值。使用此值不应用限制效果。
size：该值开启元素的大小限制。这意味着修改元素的大小可以不需要检查其后代。
layout：该值开启元素的布局限制。这规定外面任何东西都不会影响其内部布局，反之亦然。
style：该值打开元素的样式限制。因此，对元素及其后代可能产生影响的属性不会影响这个元素之外的任何内容。
paint：该值打开元素的绘制限制。这意味着元素的后代不会显示在其边界之外。例如，如果一个元素是屏幕外（或不可见的），它的所有元素都是屏幕外（或不可见的）。典型的用例是移动设备上的屏幕菜单。
strict：该属性适用于所有形式的限制，本质上是除去none所有上述值的组合（即包含：size layout style paint）。
content：这个值与strict但像，除了不包含size。 

3. writing-mode
writing-mode 支持下列的值:
horizontal-tb：内容为我们常规的水平排列，从左到右阅读，第二行在第一行的下方。
vertical-rl：内容垂直排列，从上到下，从右到左阅读，第二行在第一行的左侧。
vertical-lr：内容垂直排列，从上到下，从左到右阅读，第二行在第一行的右侧。
sideways-lr：内容垂直排列，从上到下，从左到右阅读，在所有的排版方式中，即使是垂直版式, 字的顶部都是向左的。
sideways-rl：内容垂直排列，从上到下，从右到左阅读，在所有的排版方式中，即使是垂直版式，字的顶部都是向右。

4. clip-path
clip-path: <clip-source> | [ <basic-shape> | <geometry-box> ] | none

这些值的含义:
clip-source: 引用内部或外部SVG元素的URL
basic-shape: 基础形状函数， 定义在 CSS Shapes specification
geometry-box: 如果明确与“组合，它将为基本形状提供参考框。
none: 没有剪贴

5. will-change
可以给我们的浏览器一些重要的暗示，通过使用will-change属性，提前通知元素将会发生什么改变。因为这个属性，浏览器将在元素被改变之前有时间完成其优化工作，相应地分配内存。
这个属性可以有4个值：

auto: 实行标准浏览器优化。
scroll-position: 指明元素的滚动位置将会出现动画变化，浏览器应该为滚动视窗内容的不可见部分事先做好准备。
contents: 指明元素的内容将会发生变化，浏览器不要缓存它们的内容。
<custom-ident>: 指明will-change实施的目标属性，比如transform 或 opacity。
如果想通知浏览器会发生一个transform方面的变化，可以这样写：
.element {
	will-change: transform;
}
我们还可以指定多个值，用逗号分隔，例如：
.element {
	will-change: transform, opacity;
}

16 个 CSS 高级技巧汇总
1.这段代码会让你的彩色照片显示为黑白照片，是不是很酷？
img.desaturate {
    filter: grayscale(100%);
    -webkit-filter: grayscale(100%);
    -moz-filter: grayscale(100%);
    -ms-filter: grayscale(100%);
    -o-filter: grayscale(100%);
}

2. 使用 :not() 在菜单上应用/取消应用边框
先给每一个菜单项添加边框
/* add border */
.nav li {
  border-right: 1px solid #666;
}
然后再除去最后一个元素
// remove border /
.nav li:last-child {
  border-right: none;
}
可以直接使用 :not() 伪类来应用元素：
.nav li:not(:last-child) {
  border-right: 1px solid #666;
}
这样代码就干净，易读，易于理解了。
当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：
.nav li:first-child ~ li {
  border-left: 1px solid #666;
}

3. 页面顶部阴影
下面这个简单的 CSS3 代码片段可以给网页加上漂亮的顶部阴影效果：
body:before {
          content: "";
          position: fixed;
          top: -10px;
          left: 0;
          width: 100%;
          height: 10px;
          -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
          -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
          box-shadow: 0px 0px 10px rgba(0,0,0,.8);
          z-index: 100;
}

4. 给 body 添加行高
你不需要分别添加 line-height 到每个p,h标记等。只要添加到 body 即可：
body {
  line-height: 1;
}
这样文本元素就可以很容易地从 body 继承。

5. 所有一切都垂直居中
html, body {
  height: 100%;
  margin: 0;
}
body {
  -webkit-align-items: center;  
  -ms-flex-align: center;  
  align-items: center;
  display: -webkit-flex;
  display: flex;
}

6. 逗号分隔的列表
让HTML列表项看上去像一个真正的，用逗号分隔的列表：
ul > li:not(:last-child)::after {
  content: ",";
}
对最后一个列表项使用 :not() 伪类。

7. 使用负的 nth-child 选择项目
li {
  display: none;
}

/* select items 1 through 3 and display them */
li:nth-child(-n+3) {
  display: block;
}

8. 对图标使用 SVG
我们没有理由不对图标使用SVG：
.logo {
  background: url("logo.svg");
}
SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。

9. 优化显示文本
有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：
html {
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
}
注：请负责任地使用 optimizeLegibility。此外，IE /Edge没有 text-rendering 支持。

10. 对纯 CSS 滑块使用 max-height
使用 max-height 和溢出隐藏来实现只有CSS的滑块：
.slider ul {
  max-height: 0;
  overlow: hidden;
}
.slider:hover ul {
  max-height: 1000px;
  transition: .3s ease;
}

11. 继承 box-sizing
让 box-sizing 继承 html：
html {
  box-sizing: border-box;
}
*, *:before, *:after {
  box-sizing: inherit;
}

12. 表格单元格等宽
表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽：
.calendar {
  table-layout: fixed;
}

13. 用 Flexbox 摆脱外边距的各种 hack
当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了：
.list {
  display: flex;
  justify-content: space-between;
}
.list .person {
  flex-basis: 23%;
}
现在，列表分隔符就会在均匀间隔的位置出现。

14. 使用属性选择器用于空链接
当a元素没有文本值，但 href 属性有链接的时候显示链接：
a[href^="http"]:empty::before {
  content: attr(href);
}
相当方便。

15. 禁用鼠标事件
CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。
.disabled { pointer-events: none; }

16. 模糊文本
简单但很漂亮的文本模糊效果，简单又好看！
.blur {
   color: transparent;
   text-shadow: 0 0 5px rgba(0,0,0,0.5);
}

17.自定义属性
:root {
	--global--color-primary: #28303d;
}

a {
	color: var(--global--color-primary);
}

18.@supports  如果你熟悉媒体查询，使用支持检查将非常容易。下面是如何使用它：
@supports (display: grid) {
	.site-content {
		display: grid;
	}
}

19.content-visibility 是一个非常酷的新CSS功能，可以提高网站性能。它的工作原理基本上就像懒惰加载一样，只是不针对图片，而是针对任何HTML元素。您可以使用它来阻止网站的任何部分加载，直到其可见为止。

使用也超级简单，只需将其应用到你所选择的元素上，就像这样：

.content-below-fold {
	content-visibility: auto;
}

20.:is 和 :where
在我们的新CSS特性列表中，你可能不知道的最后一个条目是 :is 和 :where 伪类。它们允许你通过缩短CSS选择器的列表来减少CSS标记的重复。
例如，比较一下：
.maina:hover,
.sidebara:hover,
.site-footera:hover {
	/* markup goes here */
}
对此：
:is(.main, .sidebar, .site-footer) a:hover {
	/* markup goes here */
}
相同的东西适用于 :where：
:where(.main, .sidebar, .site-footer) a:hover {
	/* markup goes here */
}
如果标记是一样的，有什么区别呢？不同的是 :is 更具体。它取括号中最特殊的元素的特殊性程度。相比之下，:where 的特异性永远是零。因此，再往下覆盖就容易多了。
浏览器的应用还有点不稳定，但慢慢就会有了。所以，请随意开始尝试。

主要Promise中then方法接收的参数  如果是函数则放置到微任务队列  如果不是函数类似于Promise.resolve().then(console.log(999))这种是会立即执行的  算是同步代码

conic-gradient 配合 CSS @property 实现饼图动画
syntax：该自定义属性的语法规则，也可以理解为表示定义的自定义属性的类型
length
number
percentage
length-percentage
color
image
url
integer
angle
time
resolution
transform-list
transform-function
custom-ident (a custom identifier string)
inherits：是否允许继承
initial-value：初始值
@property --per {  
  syntax: '<percentage>';  
  inherits: false;  
  initial-value: 25%;  
}
div {  
  background: conic-gradient(yellowgreen, yellowgreen var(--per), transparent var(--per), transparent 100%);   
  transition: --per 300ms linear;
  &:hover {  
      --per: 60%;  
  }  
} 

1. 禁用鼠标事件、移动端禁止图片长按保存功能（PC端禁止鼠标点击事件，移动端禁止触摸事件还有长按事件）
.no-events {
  pointer-events: none
}

2.移动端禁止用户长按文字选择功能
.unselect {
  -webkit-touch-callout:none;
  -webkit-user-select:none;
  -khtml-user-select:none;
  -moz-user-select:none;
  -ms-user-select:none;
  user-select:none
}

3.文字模糊
.blur {
  color: transparent;
  text-shadow: 0 0 5px rgba(0, 0, 0, 0.5)
}

4.css将字符串转换为驼峰等方式
const str = 'this junjin'
.toCapital{
    text-transform: capitalize; // This Junjin
    text-transform: uppercase; // THIS JUNJIN
    text-transform: lowercase; // this junjin
}

5.resize属性，让普通元素可以像textarea那样伸缩
.box { 
    resize: both; 
    resize: horizontal; // 只可调整宽度
    resize: vertical; // 只可调整高度
}

6.使用text-align-last对齐两端文本
// 适用于 未知字数的文本两端对齐
ul li {
    text-align-last: justify;
}

7.使用pointer-events禁用事件触发
// 发送请求，避免多次点击等情景；相当于button的disabled属性
p {
    pointer-events:none
}

8.文字渐变
.text-gradient {
  background-image: -webkit-gradient(linear, 0 0, 0 bottom, from(rgb(63, 52, 219)), to(rgb(233, 86, 86)));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent
}

9.超出N行显示省略号
.hide-text-n {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: n;
  overflow: hidden
}

10.最后一个元素不需要边框、边距等
ul > li:not(:last-child) {
  border-bottom: 1px solid #ccc
}

11、CSS实现文本两端对齐
.wrap {
    text-align: justify;
    text-justify: distribute-all-lines;  //ie6-8
    text-align-last: justify;  //一个块或行的最后一行对齐方式
    -moz-text-align-last: justify;
    -webkit-text-align-last: justify;
}

12、识别字符串里的 '\n' 并换行
一般在富文本中返回换行符不是<br>的标签，而且\n。不使用正则转换的情况下，可通过下面样式实现换行。

body {
   white-space: pre-line;
}

13、修改input输入框中光标的颜色不改变字体的颜色
input{
    color:  #fff;
    caret-color: red;
}

14、用CSS动画实现省略号动画
这个片段将帮助你制造一个ellipsis的动画，对于简单的加载状态是很有用的，而不用去使用gif图像。
.loading:after {
    overflow: hidden;
    display: inline-block;
    vertical-align: bottom;
    animation: ellipsis 2s infinite;
    content: "\2026"; /* ascii code for the ellipsis character */
}
@keyframes ellipsis {    from {
        width: 2px;
    }
    to {
        width: 15px;
    }
}

15、自定义文本选择
::selection { background: #e2eae2; }
::-moz-selection { background: #e2eae2; }
::-webkit-selection { background: #e2eae2; }

1.Function.prototype 竟然是个函数类型。而自定义函数的原型却是对象类型。
typeof Function.prototype === 'function';  // true
function People() {}
typeof People.prototype === 'object';      // true
所以我们设置空函数可以这么做：
// Good 
const noop = Function.prototype;
// Bad
const noop = () => {};

2.一个变量真的会不等于自身吗？
const x = NaN;
x !== x  // true
这是目前为止 js 语言中唯一的一个不等于自己的数据 所以如果您想兼容旧浏览器，用 x !== x 来判断是不是NaN，是一个不错的方案。

3.构造函数如果 return了新的数据

// 不返回
function People() {}
const people = new People();   // People {}

// 返回数字
function People() {
  return 1;
}
const people = new People();   // People {}

// 返回新对象
function Animal() {
  return {
    hello: 'world',
  };
}
const animal = new Animal();  // { hello: 'world' }
在实例化构造函数时，返回非对象类型将不生效

4.es6函数带默认参数时将生成声明作用域
var x = 10;
function fn(x = 2, y = function () { return x + 1 }) {
  var x = 5;
  return y();
}
fn();   //3 

5.函数表达式（非函数声明）中的函数名不可覆盖
const c = function CC() {
  CC = 123;
  return CC;
};
typeof c()// Function
当然，如果设置 var CC = 123 ，加声明关键词是可以覆盖的

6.严格模式下，函数的 this 是 undefined 而不是 Window
// 非严格
function fn1() {
  return this;
}
fn1(); // Window
// 严格
function fn2() {
  'use strict';
  return this;
}
fn2(); // undefined
对于模块化的经过webpack打包的代码，基本都是严格模式的代码。

7.parseInt 太小的数字会产生 bug

parseInt(0.00000000454);  // 4  这里不是bug   这是因为数字会首先转成字符串也就是自然数的表示法  4e***等   经过parseInt之后转成了4
parseInt(10.23);          // 10

8. 神奇的null
[typeof null, null instanceof Object]

// A. ["object", false]
// B. [null, false]
// C. ["object", true]
// D. other
答案是A null 值并不是以 Object 原型创建出来的，所以 null instanceof Object 返回 false。

9. 愤怒的reduce
[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]

// A. an error
// B. [9, 0]
// C. [9, NaN]
// D. [9, undefined]
答案是A。MDN文档中关于 Array.prototype.reduce() 写得很清楚：
如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。

10.该死的优先级
var val = 'smtg';
console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');

// A. Value is Something
// B. Value is Nothing
// C. NaN
// D. other
答案是D。实际上输出 "Something"，因为 + 的优先级比条件运算符 condition ? val1 : val2 的优先级高

11.死循环陷阱
var END = Math.pow(2, 53);
var START = END - 100;
var count = 0;
for (var i = START; i <= END; i++) { 
  count++;
}
console.log(count);
// A. 0
// B. 100
// C. 101
// D. other
答案是D。在JavaScript中，2^53 是最大的值，没有比这更大的值了。所以 2^53 + 1 == 2^53，所以这个循环无法终止。

12.过滤器魔法
var ary = [0,1,2];
ary[10] = 10;
ary.filter(function(x) {
  return x === undefined;
});

// A. [undefined x 7]
// B. [0, 1, 2, 10]
// C. []
// D. [undefined]
答案是C。看MDN官方文档的描述：
filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。**callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。**那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。

13. 字符串陷阱
function showCase(value) {
  switch(value) {
    case 'A':
      console.log('Case A');
      break;
    case 'B':
      console.log('Case B');
      break;
    case undefined:
      console.log('undefined');
      break;
    default:
      console.log('Do not know!');
  }
}
showCase(new String('A'));

// A. Case A
// B. Case B
// C. Do not know!
// D. undefined
答案是C。在 switch 内部使用严格相等 === 进行判断，并且 new String("A") 返回的是一个对象，而 String("A") 则是直接返回字符串 "A"。你也可以参考MDN中对原始字符串和String对象的区分：

14.并非都是奇偶
function isOdd(num) {
  return num % 2 == 1;
}

function isEven(num) {
  return num % 2 == 0;
}

function isSane(num) {
  return isEven(num) || isOdd(num);
}

var values = [7, 4, "13", -9, Infinity];
values.map(isSane);

// A. [true, true, true, true, true]
// B. [true, true, true, true, false]
// C. [true, true, true, false, false]
// D. [true, true, false, false, false]
答案是C。-9 % 2 = -1 以及 Infinity % 2 = NaN，求余运算符会保留符号，所以只有 isEven 的判断是可靠的。

15.数组原型是数组
Array.isArray( Array.prototype )

// A. true
// B. false
// C. error
// D. other
答案是A。一个鲜为人知的事实：其实 Array.prototype 也是一个数组。这点在MDN文档中提到过。

16.撒旦之子“==”
[]==[]
// A. true
// B. false
// C. error
// D. other
答案是B。ES5规范11.9.3.1-f指出：如果比较的两个对象指向的是同一个对象，就返回 true，否则就返回 false，显然，这是两个不同的数组对象。

17.Math.min() 是Infinity   Math.max()是-Infinity

18.css优化js
（1）多行展示
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 2;

（2）重要的元素始终显示在页面上
CSS 有一个属性 position:sticky 可以实现这种行为
除了IE和旧版的 Chrome 或 Firefox 之外，所有浏览器都支持sticky。对于这些旧版的浏览器，元素仅支持默认值 position:static，而且不会处理 top、bottom、left 和 right 的值。如果你需要支持这些浏览器，则请记住这一点。旧版的 Safari 需要 -webkit-sticky 前缀。

（3）平滑滚动
CSS有一个属性 scroll-behavior: smooth 和 {behavior: 'smooth'}，可以代替JavaScript的 scroll 、 scrollTo 和 scrollIntoView ，将所有有关计时的决定都交给CSS。这样可能更符合常用设备的常规做法。
scroll-behavior: smooth

（4）滚动到吸附点
CSS的滚动吸附功能可以处理该行为。在滚动的容器中，定义 scroll-snap-type 来指示吸附的方向，以及吸附必定发生还是仅在接近吸附点时发生。然后在容器的子元素中定义 scroll-snap-align 来标明吸附点。
最外层盒子设置scroll-snap-type:x mandatory
每一个滚动的盒子图片 scroll-snap-align:start

(5)延迟图像加载
去年，所有浏览器（Safari除外）都实现了 <img> 元素的 loading="lazy" 属性。如果你的网站会加载所有图像，那么可以尝试下这个属性。几乎不需任何代价，就可以让网站加载变快。

(6)优雅的实现水平居中和垂直居中
.parent {
    display: grid;
    place-items: center;
  }

(7)可解构的自适应布局（The Deconstructed Pancake）
<div class="ex2">
  <div class="parent white">
    <div class="box green">1</div>
    <div class="box green">2</div>
    <div class="box green">3</div>
  </div>
</div>
.ex2 .parent {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}
.ex2 .box {
  background-color: #4da84d;
  flex: 1 1 350px; /*  flex-grow: 1 ，表示自动延展到最大宽度 */
  margin: 5px;
}

(8)经典的侧边栏
grid-template-columns: minmax(<min>, <max>) ...
同样使用grid布局，结合可以minmax()实现弹性的的这在你要适应大屏幕的时候很有用）。minmax(<min>, <max>)就是字面意思。结合<flex>单位，非常优雅，避免了数学计算宽度等不灵活的手段（的我们设置间隙手段时候）。
.ex3 .parent {
  display: grid;
  grid-template-columns: minmax(150px, 25%) 1fr;
}

(9)固定的页眉和页脚
<div class="parent">
  <header class="blue section" contenteditable>Header</header>
  <main class="coral section" contenteditable>Main</main>
  <footer class="purple section" contenteditable>Footer Content</footer>
</div>
.ex4 .parent {
  display: grid;
  grid-template-rows: auto 1fr auto;
}

(10)RAM技巧
.ex7 .parent {
    display: grid;
    grid-gap: 1rem;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  }

(11)在展现CMS或其他设计内容时，我们会期待图片，视频，卡片能够按照固定的比例进行布局。而最新的aspect-ratio可以优雅的实现该功能
<div class="parent white">
  <div class="card blue">
    <h1>Video Title</h1>
    <div class="visual green"></div>
    <p>Descriptive Text. This demo works in Chromium 84+.</p>
  </div>
</div>
.ex10 .parent {
  display: grid;
  place-items: center;
}
.ex10 .visual {
  aspect-ratio: 16 / 9;
}
.ex10 .card {
  width: 50%;
  display: flex;
  flex-direction: column;
  padding: 1rem;
}

(12)a == 1 && a == 2 && a == 3，那你可以实现a === 1 && a === 2 && a === 3吗？
// 当然，你也可以把count作为属性放在a对象上
// let count = 1;
// let a = {
//   valueOf: function () {
//     return count++;
//   },
// };
// console.log(a == 1 && a == 2 && a == 3); // true

let count = 1;
Object.defineProperty(window, 'a', {
  get: function () {
    return count++;
  },
});
console.log(a === 1 && a === 2 && a === 3); // true

(13)十进制二进制互转，真的不用那么麻烦
使用NumberObject.toString(radix)十进制转二进制：
// 如有补齐位数的需求，可通过判断返回值的长度在前面加0
let num = 10;
console.log(num.toString(2)); // 1010
•使用parseInt(string, radix);二进制转十进制：
let num = 1010101;
console.log(parseInt(num, 2)); // 85

(14)不用加减乘除如何做加法——位运算让你的代码更高效
JS 按位运算符的妙用
使用&运算符判断一个数的奇偶（只需记住 0 和 1 与 1 进行&运算的结果即可）：
•偶数 & 1 = 0
•奇数 & 1 = 1
使用~~，>>,<<,>>>,|来取整：
•~~Math.PI：3（按位取反再取反）
利用^来完成比较两个数是否相等：!(a ^ b)
使用^来完成值交换
a ^= b;
b ^= a;
a ^= b;

(15)无聊的脑筋急转弯，不借助第三个变量交换 a,b 两个变量值的 N 种方法
方法一：加减
a = a + b;
b = a - b;
a = a - b;
•方法二：位运算
a ^= b;
b ^= a;
a ^= b;
•方法三：对象或者数组
a = { a, b };
b = a.a;
a = a.b;
// a = [a, b];
// b = a[0];
// a = a[1];
•方法四：ES 6 解构赋值
[a, b] = [b, a];
•方案五：运算符优先级
a = [b, (b = a)][0];

(16)产品说要按照中文拼音顺序排序？
使用 stringObject.localeCompare(target) 方法实现中文按照拼音顺序排序
var array = ['上海', '北京', '杭州', '广东', '深圳', '西安'];
// localeCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。
array = array.sort((item1, item2) => item1.localeCompare(item2));
// ["北京", "广东", "杭州", "上海", "深圳", "西安"]

(17)图片资源懒加载
npm install vue-lazyload --save-dev
在入口文件 man.js 中引入并使用
import VueLazyload from 'vue-lazyload'
然后再 vue 中直接使用
Vue.use(VueLazyload)
或者添加自定义选项
Vue.use(VueLazyload, {
preLoad: 1.3,
error: 'dist/error.png',
loading: 'dist/loading.gif',
attempt: 1
})
在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：
<img v-lazy="/static/img/1.png">
以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。

(18)第三方插件的按需引入
我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：
1）首先，安装 babel-plugin-component ：
npm install babel-plugin-component -D
2）然后，将 .babelrc 修改为：
{
 "presets": [["es2015", { "modules": false }]],
 "plugins": [
 [
 "component",
 {
 "libraryName": "element-ui",
 "styleLibraryName": "theme-chalk"
 }
 ]
 ]
}
3）在 main.js 中引入部分组件：
import Vue from 'vue';
import { Button, Select } from 'element-ui';
 Vue.use(Button)
 Vue.use(Select)

 (19)优化无限列表性能 参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表的场景的

 5个不常提及的HTML技巧
 (1)图片懒加载
可以通过为图片文件添加loading="lazy"的属性来实现:
<img src="image.png" loading="lazy" alt="lazy" width="200" height="200" />
 (2)输入提示
 HTML也是能够让我们来实现预定义输入建议功能的，通过<datalist>标签来实现。需要注意的是，使用时这个标签的id属性需要和input元素的list属性一致。
<label for="country">请选择喜欢的国家:</label>
<input list="countries" name="country" id="country">
<datalist id="countries">
  <option value="UK">
  <option value="Germany">
  <option value="USA">
  <option value="Japan">
  <option value="India">
  <option value=“China”>
</datalist>
 (3)Picture标签
 HTML提供了<picture>标签，允许我们来添加多张图片资源，并且根据不同的分辨率需求来展示不同的图片。
<picture>
  <source media="(min-width:768px)" srcset="med_flower.jpg">
  <source media="(min-width:495px)" srcset="small_flower.jpg">
  <img src="high_flower" style="width: auto;" />
</picture>
 (4)Base URL
 <base>标记必须具有href和target属性。
 <head>
  <base href="https://www.weibo.com/" target="_blank">  
</head>
<body>
  <a href="jackiechan">成龙</a>
  <a href="kukoujialing">贾玲</a>
</body>
 (5)页面重定向（刷新）
 我们经常会遇到有些站点会有这样一个功能，“5s后页面将跳转”。这个交互可以嵌入到HTML中，直接通过<meta>标签，设置http-equiv="refresh"来实现
 <meta http-equiv="refresh" content="4; URL='https://google.com' />

Node 环境的判断
typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]'